<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSS居中</title>
    <link href="/2020/12/13/CSS%E5%B1%85%E4%B8%AD/"/>
    <url>/2020/12/13/CSS%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>1.第一类，div中的文字或者图片在div中垂直水平居中</p><p>2.第二类，div元素相对于它的父元素垂直水平居中</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="第一类-文字-图片"><a href="#第一类-文字-图片" class="headerlink" title="第一类:文字/图片"></a>第一类:文字/图片</h2><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>仅限子元素为行内元素或图片，且只有单行/单个</p><h2 id="第二类-div子元素"><a href="#第二类-div子元素" class="headerlink" title="第二类:div子元素"></a>第二类:div子元素</h2><h3 id="1-margin"><a href="#1-margin" class="headerlink" title="1.margin"></a>1.margin</h3><p>父元素设置<code>border</code>或者<code>padding</code>，子元素设置<code>magin</code>。灵感来源于《CSS权威指南》第三版 </p><ul><li><p>p180 auto小节</p></li><li><p>p182 合并外边距详解小节</p></li></ul><blockquote><p>在包含块上设置边框或内边距时，会使其子元素的外边距包含在包含块内</p></blockquote><p>也就是说父元素在设置边框或者内边距后，子元素的margin属性在垂直方向上可以直接以父元素边框为参考对象</p><p>缺点: 需要知道子元素宽高，并且父元素需额外添加没有太大意义的<code>border/padding</code></p><p>事实上也可应用于图片，见示例</p><p>父元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">transparent</span>;<span class="hljs-comment">/* 或者设置padding */</span></code></pre><p>子元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">orange</span>;<span class="hljs-selector-tag">margin</span>: <span class="hljs-selector-tag">calc</span>(50% <span class="hljs-selector-tag">-</span> 2<span class="hljs-selector-class">.5em</span>) <span class="hljs-selector-tag">auto</span>;</code></pre><h3 id="relative-transform"><a href="#relative-transform" class="headerlink" title="relative+transform"></a>relative+transform</h3><p>父元素不用更改</p><p>子元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">relative</span>;<span class="hljs-selector-tag">left</span>: 50%;<span class="hljs-selector-tag">top</span>: 50%;<span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">translate</span>(<span class="hljs-selector-tag">-50</span>%, <span class="hljs-selector-tag">-50</span>%);</code></pre><p>缺点：行内元素失效</p><h2 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h2><p>优点: 无需知道子元素的宽高</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>父元素中添加</p><pre><code class="hljs css"><span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">flex</span>;<span class="hljs-selector-tag">justify-content</span>: <span class="hljs-selector-tag">center</span>;<span class="hljs-selector-tag">align-items</span>: <span class="hljs-selector-tag">center</span>;<span class="hljs-comment">/* flex-wrap: wrap; 换行 */</span><span class="hljs-selector-tag">flex-direction</span>: <span class="hljs-selector-tag">column</span>;<span class="hljs-comment">/* 调主轴 */</span></code></pre><h3 id="relative-absolute-transform"><a href="#relative-absolute-transform" class="headerlink" title="relative+absolute(+transform)"></a>relative+absolute(+transform)</h3><p>父元素使用<code>position: relative</code>，子元素设置如下</p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-selector-tag">left</span>: 50%;<span class="hljs-selector-tag">top</span>: 50%;<span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">translate</span>(<span class="hljs-selector-tag">-50</span>%,<span class="hljs-selector-tag">-50</span>%);</code></pre><p>当然，如果标签自带<code>margin</code>或<code>padding</code>值，记得清除，否则translate移动的值将不是你想要的，除非你使用了<code>box-sizing: border-box</code> 。详情参见盒模型的宽高计算</p><p>定位方式除了上面这种方式，还有另一种奇技淫巧: </p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-selector-tag">top</span>: 0;<span class="hljs-selector-tag">right</span>: 0;<span class="hljs-selector-tag">bottom</span>: 0;<span class="hljs-selector-tag">left</span>: 0;<span class="hljs-selector-tag">margin</span>: <span class="hljs-selector-tag">auto</span>;</code></pre><p>缺点：子元素有多个的时侯，存在重叠问题</p><h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><p>表格实际上越来越少用到了，可能会有潜在bug。目前没发现吧</p><p>父元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">table-cell</span>;<span class="hljs-selector-tag">text-align</span>: <span class="hljs-selector-tag">center</span>;<span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">middle</span>;</code></pre><p>子元素</p><p>行内元素无需调整，块级元素需要加上<code>display: inline-block</code></p><h3 id="伪元素-vertical-align"><a href="#伪元素-vertical-align" class="headerlink" title="伪元素+vertical-align"></a>伪元素+vertical-align</h3><p>这个我是真的服了，奇技淫巧系列</p><p>父元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">text-align</span>: <span class="hljs-selector-tag">center</span>;</code></pre><p>伪元素</p><pre><code class="hljs css">content: &#x27;&#x27;;<span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">green</span>;<span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">inline-block</span>;<span class="hljs-selector-tag">height</span>: 100%;<span class="hljs-selector-tag">width</span>: 0;<span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">middle</span>;</code></pre><p>子元素</p><pre><code class="hljs css"><span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">middle</span>;</code></pre><p>  因为vertical-align实际上是给行内元素用的，所以块级元素需要额外加上<code>inline-block</code></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>click/touch长按与拖动</title>
    <link href="/2020/12/05/click%E6%88%96touch%E9%95%BF%E6%8C%89%E4%B8%8E%E6%8B%96%E5%8A%A8/"/>
    <url>/2020/12/05/click%E6%88%96touch%E9%95%BF%E6%8C%89%E4%B8%8E%E6%8B%96%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>某2020前端互助群的每周议题(四)  </p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><p>在body元素内Append 20个类名为<code>.box</code>的盒子</p></li><li><p>鼠标活手指长按盒子元素350ms，新增类名<code>.active</code>,普通点击无任何变化,点击空白，移除所有<code>.active</code> 元素类名</p></li><li><p>鼠标或手指长按盒子元素350ms（不抬起）,然后滑动选框，选框范围内所有盒子元素新增类名<code>.active</code>背景高亮</p></li></ul><p>效果如下</p><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/189998/1559222960860-169d14c9-1df8-4a81-a0fa-f0aa63c49bd0.gif"></p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">display</span>: inline-block;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">background-color</span>: gray;&#125;<span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.active</span> &#123;    <span class="hljs-attribute">background-color</span>: skyblue;&#125;</code></pre><h1 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://codepen.io/litstronger/pen/vYXGeaL">演示地址</a></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.content</span> &#123;</span>            position: relative;        &#125;<span class="css">        <span class="hljs-selector-class">.box</span> &#123;</span>            display: inline-block;            width: 100px;            height: 100px;            margin: 10px;            background-color: gray;        &#125;<span class="css">        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.active</span> &#123;</span>            background-color: skyblue;        &#125;<span class="css">        <span class="hljs-comment">/* 阻止内容被选中 */</span></span><span class="css">        <span class="hljs-selector-class">.unselect</span> &#123;</span>            -webkit-user-select: none;            -moz-user-select: none;            -khtml-user-select: none;            -ms-user-select: none;<span class="css">            <span class="hljs-comment">/* 以下两个属性目前并未支持，写在这里为了减少风险 */</span></span>            -o-user-select: none;            user-select: none;        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> boxNum = <span class="hljs-number">20</span>; <span class="hljs-comment">// 盒子个数</span></span><span class="javascript">    <span class="hljs-keyword">let</span> holdTime = <span class="hljs-number">350</span>; <span class="hljs-comment">// click/touch激活所需时间</span></span><span class="javascript">    <span class="hljs-keyword">let</span> boxList = [];</span><span class="javascript">    <span class="hljs-keyword">let</span> cont = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.content&#x27;</span>);</span><span class="javascript">    <span class="hljs-keyword">let</span> activeFlag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 是否激活</span></span><span class="javascript">    <span class="hljs-keyword">let</span> mask;  <span class="hljs-comment">// 选区遮罩</span></span><span class="javascript">    <span class="hljs-keyword">let</span> timerId;</span><span class="javascript">    <span class="hljs-keyword">let</span> startPointX = <span class="hljs-number">0</span>, startPointY = <span class="hljs-number">0</span>;</span><span class="javascript">    <span class="hljs-keyword">let</span> movingPointX = <span class="hljs-number">0</span>, movingPointY = <span class="hljs-number">0</span>;</span><span class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; boxNum; i++) &#123;</span><span class="javascript">        <span class="hljs-keyword">let</span> item = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);</span><span class="javascript">        item.classList.add(<span class="hljs-string">&#x27;box&#x27;</span>)</span><span class="javascript">        item.classList.add(<span class="hljs-string">&#x27;unselect&#x27;</span>)</span>        item.onmousedown = holdDown;        item.onmouseup = holdUp;        item.ontouchstart = holdDown;        item.ontouchend = holdUp<span class="javascript">        <span class="hljs-comment">// item.textContent = &#x27;test&#x27; + i</span></span>        cont.appendChild(item);        boxList.push(item)    &#125;    cont.onmousedown = mouseDown    cont.onmouseup = mouseUp    cont.ontouchstart = touchStart    cont.ontouchend = touchEnd<span class="javascript">    <span class="hljs-built_in">document</span>.onmouseleave = mouseLeave</span><span class="javascript">    <span class="hljs-comment">// 计时激活</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">holdDown</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(e)</span><span class="javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><span class="javascript">        <span class="hljs-keyword">let</span> endTime = <span class="hljs-number">0</span>;</span><span class="javascript">        timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">            endTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><span class="javascript">            <span class="hljs-built_in">console</span>.log(endTime - startTime)</span>            if (endTime - startTime &gt;= 350) &#123;<span class="javascript">                <span class="hljs-built_in">clearInterval</span>(timerId);</span><span class="javascript">                <span class="hljs-comment">// alert(&quot;长按了&quot;);</span></span><span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;duration of the click/touch:&quot;</span>, endTime - startTime)</span><span class="javascript">                <span class="hljs-built_in">this</span>.classList.add(<span class="hljs-string">&#x27;active&#x27;</span>)</span><span class="javascript">                activeFlag = <span class="hljs-literal">true</span></span>            &#125;        &#125;, 50)    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">holdUp</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">clearInterval</span>(timerId);</span>    &#125;<span class="javascript">    <span class="hljs-comment">/* mouseEvent相关处理函数 */</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseDown</span>(<span class="hljs-params">e</span>) </span>&#123;</span>        startPointX = e.clientX        startPointY = e.clientY<span class="javascript">        <span class="hljs-built_in">console</span>.log(startPointX, startPointY)</span><span class="javascript">        <span class="hljs-comment">// 创建遮罩层</span></span>        createMask()        cont.onmousemove = mouseMove    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseMove</span>(<span class="hljs-params">e</span>) </span>&#123;</span>        if (activeFlag) &#123;            activeMaskArea(e.clientX, e.clientY)        &#125;    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseUp</span>(<span class="hljs-params"></span>) </span>&#123;</span>        if (activeFlag) &#123;<span class="javascript">            activeFlag = <span class="hljs-literal">false</span></span>            mask.remove()        &#125;<span class="javascript">        cont.onmousemove = <span class="hljs-function">() =&gt;</span> &#123; &#125;</span>    &#125;<span class="javascript">    <span class="hljs-comment">// 鼠标移出浏览器区域后取消遮罩，因为鼠标移出浏览器后再松开触发不了mouseup </span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseLeave</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mouse leave&#x27;</span>)</span>        if (activeFlag) &#123;<span class="javascript">            activeFlag = <span class="hljs-literal">false</span></span>            mask.remove()<span class="javascript">            cont.onmousemove = <span class="hljs-function">() =&gt;</span> &#123; &#125;</span>        &#125;    &#125;<span class="javascript">    <span class="hljs-comment">/* touchEvent相关处理函数 */</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">touchStart</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;touch start&quot;</span>)</span>        startPointX = e.touches[0].clientX        startPointY = e.touches[0].clientY<span class="javascript">        <span class="hljs-built_in">console</span>.log(startPointX, startPointY)</span>        createMask()        cont.ontouchmove = touchMove    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">touchMove</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(e)</span>        if (activeFlag) &#123;<span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;active move&#x27;</span>)</span>            activeMaskArea(e.touches[0].clientX, e.touches[0].clientY)        &#125;    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">touchEnd</span>(<span class="hljs-params">e</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;touch end&#x27;</span>)</span><span class="javascript">        <span class="hljs-comment">// console.log(e)</span></span>        if (activeFlag) &#123;<span class="javascript">            activeFlag = <span class="hljs-literal">false</span></span>            mask.remove()        &#125;<span class="javascript">        cont.ontouchmove = <span class="hljs-function">() =&gt;</span> &#123; &#125;</span><span class="javascript">        e.preventDefault() <span class="hljs-comment">// 取消后续mouseEvent， 避免执行touchEvent后再执行mouseEvent</span></span>    &#125;<span class="javascript">    <span class="hljs-comment">/* 通用函数 */</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMask</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-comment">// 遮罩</span></span><span class="javascript">        mask = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);</span><span class="javascript">        mask.style.backgroundColor = <span class="hljs-string">&#x27;yellow&#x27;</span></span><span class="javascript">        mask.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span></span><span class="javascript">        mask.style.opacity = <span class="hljs-string">&#x27;0.3&#x27;</span></span>        cont.appendChild(mask)    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activeMaskArea</span>(<span class="hljs-params">eX, eY</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-comment">// 遮罩层定位</span></span><span class="javascript">        <span class="hljs-keyword">if</span> (eX &gt; startPointX) &#123;  <span class="hljs-comment">// 向左or向右 拖动</span></span><span class="javascript">            mask.style.left = startPointX + <span class="hljs-string">&#x27;px&#x27;</span></span><span class="javascript">            mask.style.width = (eX - startPointX) + <span class="hljs-string">&#x27;px&#x27;</span></span>        &#125;<span class="javascript">        <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// 左</span></span><span class="javascript">            mask.style.left = eX + <span class="hljs-string">&#x27;px&#x27;</span></span><span class="javascript">            mask.style.width = (startPointX - eX) + <span class="hljs-string">&#x27;px&#x27;</span></span>        &#125;<span class="javascript">        <span class="hljs-keyword">if</span> (eY &gt; startPointY) &#123;    <span class="hljs-comment">// 向上or向下 拖动</span></span><span class="javascript">            mask.style.top = startPointY + <span class="hljs-string">&#x27;px&#x27;</span></span><span class="javascript">            mask.style.height = (eY - startPointY) + <span class="hljs-string">&#x27;px&#x27;</span></span>        &#125;<span class="javascript">        <span class="hljs-keyword">else</span> &#123;                           <span class="hljs-comment">// 上</span></span><span class="javascript">            mask.style.top = eY + <span class="hljs-string">&#x27;px&#x27;</span></span><span class="javascript">            mask.style.height = (startPointY - eY) + <span class="hljs-string">&#x27;px&#x27;</span></span>        &#125;<span class="javascript">        <span class="hljs-comment">// 处理选区内元素</span></span><span class="javascript">        boxList.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">if</span> ((e.offsetLeft + e.offsetWidth &gt; mask.offsetLeft)  <span class="hljs-comment">// 遮罩左边界</span></span><span class="javascript">                &amp;&amp; (e.offsetLeft &lt; mask.offsetLeft + mask.offsetWidth)   <span class="hljs-comment">// 遮罩右边界     </span></span><span class="javascript">                &amp;&amp; (e.offsetTop + e.offsetHeight &gt; mask.offsetTop)   <span class="hljs-comment">// 遮罩上边界   </span></span><span class="javascript">                &amp;&amp; (e.offsetTop &lt; mask.offsetTop + mask.offsetHeight)) &#123;   <span class="hljs-comment">// 遮罩下边界               </span></span><span class="javascript">                e.classList.add(<span class="hljs-string">&#x27;active&#x27;</span>)</span>            &#125;<span class="javascript">            <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                e.classList.remove(<span class="hljs-string">&#x27;active&#x27;</span>)</span>            &#125;        &#125;)    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events"><strong>MDN Events</strong></a></p><p><strong>mouse相关</strong></p><ul><li>mousedown</li><li>mousemove</li><li>mouseup</li><li>mouseleave</li></ul><p><strong>touch相关</strong></p><ul><li>touchdown</li><li>touchmove</li><li>touchup</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><strong>MDN mouseEvent</strong></a></p><ul><li>mouseEvent.clientX, mouseEvent.clientY</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent"><strong>MDN touchEvent</strong></a></p><ul><li><p>touches(存放touch的数组，多点触控)</p><p>A list of <a href="https://developer.mozilla.org/en/DOM/Touch"><code>Touch</code></a>es for every point of contact currently touching the surface.</p></li><li><p>Touch.clientX, Touch.clientY</p><p>触点相对于可见视区(<a href="http://www.quirksmode.org/mobile/viewports2.html">visual viewport</a>)左边沿的的X坐标</p></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents"><strong>MDN 操作文档</strong></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList"><strong>ELement.classList</strong></a></p><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetLeft">HTMLElement.offsetLeft</a></strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><strong>MDN Date</strong></a></p><p><a href="https://blog.csdn.net/weixin_45615791/article/details/104524950"><strong>javaScript按住鼠标左键选中元素， 实现框选（Rubberband）效果</strong></a></p><p><a href="https://segmentfault.com/a/1190000010430655"><strong>js实现鼠标拖拽多选功能</strong></a> 这个的实现用了jquery..</p><p><a href="https://www.cnblogs.com/moqiutao/p/7280031.html"><strong>JS与CSS阻止元素被选中及清除选中的方法总结</strong></a></p><p><a href="https://medium.com/frochu/touch-and-mouse-together-76fb69114c04"><strong>移動端瀏覽器 ：當 Touch Event 與 Mouse Event 同時存在的時候</strong></a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>刚开始时仅使用了mouseup来取消遮罩选区，其实是有bug的，因为一旦你的鼠标移出了浏览器窗口就触发不了mouseup事件了。</li><li>touchEvent触发后，mouseEvent仍然会触发，也就是说部分代码会被执行两次</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>利用mouseLeave检测鼠标是否超出区域</li></ol><pre><code class="hljs js"><span class="hljs-built_in">document</span>.onmouseleave = mouseLeave    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseLeave</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mouse leave&#x27;</span>)    <span class="hljs-keyword">if</span> (activeFlag) &#123;        activeFlag = <span class="hljs-literal">false</span>        mask.remove()        cont.onmousemove = <span class="hljs-function">() =&gt;</span> &#123; &#125;    &#125;&#125;</code></pre><ol start="2"><li><p>MDN如下解释</p><blockquote><p><strong>注意:</strong> 在很多情况下，触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault"><code>event.preventDefault()</code></a> 来阻止鼠标事件被触发。</p></blockquote><p>因此可以在touchEnd事件里调用上述函数来阻止mouseEvent触发</p></li><li><p>a</p><blockquote></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css+html鼠标悬停tips</title>
    <link href="/2020/12/01/css-html%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9Ctips/"/>
    <url>/2020/12/01/css-html%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9Ctips/</url>
    
    <content type="html"><![CDATA[<p>某2020前端互助群的每周议题(三)  Part 2</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个鼠标悬停的功能，如图</p><p><img src="https://img-blog.csdnimg.cn/20201201154933160.png" alt="1606801197639"></p><p>要求：只使用CSS和HTML</p><p>可以贴出代码的实现地址例如<a href="https://codepen.io/">https://codepen.io/</a> 上提交自己的代码</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><a href="https://codepen.io/litstronger/pen/ZEpGXQZ">我的实现</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="1-初步实现"><a href="#1-初步实现" class="headerlink" title="1.初步实现"></a>1.初步实现</h3><p><code>hover</code>后出现文本提示，考虑使用伪元素<code>:after</code>来实现</p><blockquote><p> <code>:after</code>这是css2的写法，css3是<code>::after</code></p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.wrap</span> &#123;</span>    &#125;<span class="css">    <span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-tag">img</span> &#123;</span>        width: 1em;        height: 1em;    &#125;<span class="css">    <span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>        content: attr(logo-tip);<span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#222</span>;</span>        color: white;<span class="css">        <span class="hljs-selector-tag">border-radius</span>: <span class="hljs-selector-class">.2em</span>;</span><span class="css">        <span class="hljs-selector-tag">padding</span>: <span class="hljs-selector-class">.5em</span>;</span>        width: 5em;<span class="css">        <span class="hljs-selector-tag">opacity</span>: <span class="hljs-selector-class">.5</span>;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span> <span class="hljs-attr">logo-tip</span>=<span class="hljs-string">&quot;添加链接啦啦啦啦&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>初步效果如下，鼠标移上去会出现tip</p><style>    .wrap-1 {    }    .wrap-1 img {        width: 1em;        height: 1em;    }    .wrap-1:hover:after {        content: attr(logo-tip);        background: #222;        color: white;        border-radius: .2em;        padding: .5em;        width: 5em;        opacity: .5;    }</style><div class="wrap-1" logo-tip="添加链接啦啦啦啦">    <img src="https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png"></div><br><h3 id="2-调整位置"><a href="#2-调整位置" class="headerlink" title="2.调整位置"></a>2.调整位置</h3><p>接下来调整提示框的位置，修改下布局，采用<code>relative</code>+<code>absolute</code>进行定位</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.wrap</span> &#123;</span>        position: relative;        width: 1em;        height: 1em;        margin: 0 auto;    &#125;<span class="css">    <span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-tag">img</span> &#123;</span>        width: 100%;        height: 100%;    &#125;<span class="css">    <span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>        content: attr(logo-tip);<span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#222</span>;</span>        color: white;<span class="css">        <span class="hljs-selector-tag">border-radius</span>: <span class="hljs-selector-class">.2em</span>;</span><span class="css">        <span class="hljs-selector-tag">padding</span>: <span class="hljs-selector-class">.5em</span>;</span>        width: 5em;<span class="css">        <span class="hljs-selector-tag">opacity</span>: <span class="hljs-selector-class">.5</span>;</span>        position: absolute;<span class="css">        <span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>; <span class="hljs-comment">/* 方便计算宽高 */</span></span><span class="css">        <span class="hljs-selector-tag">left</span>: <span class="hljs-selector-tag">calc</span>(50% <span class="hljs-selector-tag">-</span> 2<span class="hljs-selector-class">.5em</span>);</span><span class="css">        <span class="hljs-selector-tag">top</span>: 1<span class="hljs-selector-class">.4em</span>;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span> <span class="hljs-attr">logo-tip</span>=<span class="hljs-string">&quot;添加链接啦啦啦啦&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>效果如下</p><style>    .wrap-2 {        position: relative;        width: 1em;        height: 1em;        margin: 0 auto;    }    .wrap-2 img {        width: 100%;        height: 100%;    }    .wrap-2:hover:after {        content: attr(logo-tip);        background: #222;        color: white;        border-radius: .2em;        padding: .5em;        width: 5em;        opacity: .5;        position: absolute;        box-sizing: border-box;        left: calc(50% - 2.5em);        top: 1.4em;    }</style><div class="wrap-2" logo-tip="添加链接啦啦啦啦">    <img src="https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png"></div><br><h3 id="3-制作小三角形"><a href="#3-制作小三角形" class="headerlink" title="3.制作小三角形"></a>3.制作小三角形</h3><p>可以发现，我们实现的框，还少了个三角标，如图</p><p><img src="https://img-blog.csdnimg.cn/20201201155111408.png" alt="1606805499179"></p><p>那么，如何制作一个三角标呢？</p><p>看看下面这段代码，一个<code>content</code>为2em，<code>border</code>为2em的盒子</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>    div &#123;        background: orange;        width: 2em;        height: 2em;<span class="css">        <span class="hljs-selector-tag">border</span>: 2<span class="hljs-selector-tag">em</span> <span class="hljs-selector-tag">dashed</span> <span class="hljs-selector-id">#222</span>;</span><span class="css">        <span class="hljs-selector-tag">border-color</span>: <span class="hljs-selector-tag">red</span> <span class="hljs-selector-tag">green</span> <span class="hljs-selector-id">#222</span> <span class="hljs-selector-tag">pink</span>;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>效果如下，橙色部分为<code>content</code>，彩色部分是<code>border</code></p><p><img src="https://img-blog.csdnimg.cn/20201201155126734.png" alt="1606807307250"></p><p>看到这里，不知道你悟了没有。如果我把<code>content</code>的宽高设置为0，这样就得到四个三角形，再把<code>border</code>其他三边设置为透明，注释掉背景色，那么就得到一个三角形了。</p><ul><li><p><code>content</code>宽高设置为0：<code>width: 0em; height:0em;</code></p><p><img src="https://img-blog.csdnimg.cn/20201201155138576.png" alt="1606807907331"></p></li><li><p>设置三边透明，去掉背景色</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-comment">/* background: orange; */</span>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0em</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">0em</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2em</span> dashed <span class="hljs-number">#222</span>;    <span class="hljs-attribute">border-color</span>: transparent transparent <span class="hljs-number">#222</span> transparent;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201201155305197.png" alt="1606808125689"></p></li></ul><h3 id="4-合并提示框-小三角形"><a href="#4-合并提示框-小三角形" class="headerlink" title="4.合并提示框+小三角形"></a>4.合并提示框+小三角形</h3><p>然后，再把三角形和前面实现的提示框合起来。怎么合并呢？前面我们已经用过了一个伪元素<code>:after</code>，那么这次我们可以使用另一个伪元素<code>:before</code>( css3<code>::before</code>)</p><p><strong>最终代码</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.wrap</span> &#123;</span>        position: relative;        width: 1em;        height: 1em;        margin: 0 auto;        cursor: pointer;    &#125;<span class="css">    <span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-tag">img</span> &#123;</span>        width: 100%;        height: 100%;    &#125;<span class="css">    <span class="hljs-comment">/* 提示框 */</span></span><span class="css">    <span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>        content: attr(logo-tip);<span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#222</span>;</span>        color: white;<span class="css">        <span class="hljs-selector-tag">border-radius</span>: <span class="hljs-selector-class">.2em</span>;</span><span class="css">        <span class="hljs-selector-tag">padding</span>: <span class="hljs-selector-class">.5em</span>;</span>        width: 5em;<span class="css">        <span class="hljs-selector-tag">opacity</span>: <span class="hljs-selector-class">.5</span>;</span>        position: absolute;<span class="css">        <span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>; <span class="hljs-comment">/* 方便计算宽高 */</span></span><span class="css">        <span class="hljs-comment">/* &#x27;-&#x27;运算符两边不加空格属性失效, 这一定是魔法!(原因见下文) */</span></span><span class="css">        <span class="hljs-selector-tag">left</span>: <span class="hljs-selector-tag">calc</span>(50% <span class="hljs-selector-tag">-</span> 2<span class="hljs-selector-class">.5em</span>);</span><span class="css">        <span class="hljs-selector-tag">top</span>: 1<span class="hljs-selector-class">.4em</span>;</span>    &#125;<span class="css">    <span class="hljs-comment">/* 小三角标 */</span></span><span class="css">    <span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>        content: &quot;&quot;;        box-sizing: border-box;        position: absolute;        top: 1em;<span class="css">        <span class="hljs-selector-tag">left</span>: <span class="hljs-selector-tag">calc</span>(50% <span class="hljs-selector-tag">-</span> <span class="hljs-selector-class">.2em</span>);</span>        background: linen;<span class="css">        <span class="hljs-selector-tag">width</span>: <span class="hljs-selector-class">.2em</span>;</span><span class="css">        <span class="hljs-selector-tag">height</span>: <span class="hljs-selector-class">.2em</span>;</span><span class="css">        <span class="hljs-selector-tag">border</span>: <span class="hljs-selector-class">.2em</span> <span class="hljs-selector-tag">dashed</span> <span class="hljs-selector-id">#222</span>;</span><span class="css">        <span class="hljs-selector-tag">border-color</span>: <span class="hljs-selector-tag">transparent</span> <span class="hljs-selector-tag">transparent</span> <span class="hljs-selector-id">#222</span> <span class="hljs-selector-tag">transparent</span>;</span><span class="css">        <span class="hljs-selector-tag">opacity</span>: <span class="hljs-selector-class">.5</span>;</span>    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span> <span class="hljs-attr">logo-tip</span>=<span class="hljs-string">&quot;添加链接啦啦啦啦&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>效果如下</strong></p><style>    .wrap {        position: relative;        width: 1em;        height: 1em;        margin: 0 auto;        cursor: pointer;    }    .wrap img {        width: 100%;        height: 100%;    }    /* 提示框 */    .wrap:hover:after {        content: attr(logo-tip);        background: #222;        color: white;        border-radius: .2em;        padding: .5em;        width: 5em;        opacity: .5;        position: absolute;        box-sizing: border-box;         /* '-'运算符两边不加空格属性失效, 这一定是魔法!(原因见下文) */        left: calc(50% - 2.5em);        top: 1.4em;    }    /* 小三角标 */    .wrap:hover:before{        content: "";        box-sizing: border-box;        position: absolute;        top: 1em;        left: calc(50% - .2em);        background: linen;        width: .2em;        height: .2em;        border: .2em dashed #222;        border-color: transparent transparent #222 transparent;        opacity: .5;    }</style><div class="wrap" logo-tip="添加链接啦啦啦啦">    <img src="https://hexo-1259001110.cos.ap-shanghai.myqcloud.com/link.png" alt=""></div><br></br><hr><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>MDN</strong></p><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc()">calc()</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/attr()">attr()</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after">::after</a></p></li></ul><p>图标引自<a href="https://www.iconfont.cn/search/index">阿里巴巴图标矢量库</a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>对于<code>calc()</code>，<code>+</code>和<code>-</code>运算符两边没加空格可能导致计算错误。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc()">详见MDN  calc()</a></p><blockquote><p>The <code>+</code> and <code>-</code> operators <strong>must be surrounded by whitespace</strong>. For instance, <code>calc(50% -8px)</code> will be parsed as a percentage followed by a negative length — an invalid expression — while <code>calc(50% - 8px)</code> is a percentage followed by a subtraction operator and a length. Likewise, <code>calc(8px + -50%)</code> is treated as a length followed by an addition operator and a negative percentage.</p></blockquote></li></ol><hr><ol start="2"><li><p>对于<code>attr()</code>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/attr()">详见MDN attr()</a></p><blockquote><p> <code>attr()</code> 理论上能用于所有的CSS属性但目前支持的仅有伪元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a> 属性，其他的属性和高级特性目前是实验性的。</p></blockquote></li></ol><h2 id="关于美化"><a href="#关于美化" class="headerlink" title="关于美化"></a>关于美化</h2><p>直接显示提示框其实有点僵硬，可以考虑使用<code>transition</code>属性来优化过渡。那么问题来了，给伪元素加<code>transition</code>好像很不方便……(额，其实可以的，比如先设置<code>:after</code>，再过渡到<code>:hover:after</code>)</p><p>最后我还是实现了，不过为了加这个过渡，多了一些不必要的修改。虽然效果有了，但代码不是很合理，如下。</p><p><a href="https://codepen.io/litstronger/pen/YzGyBYG">代码以及演示地址</a></p><p>因为要实现一个过渡效果，因此<code>:before</code>和<code>:after</code>必须有一个初始的状态。没错，就是这里刚开始让我觉得很难处理，因为这种情况下的<code>hover</code>似乎有<code>bug</code>。我把两个伪元素的<code>width</code>、<code>height</code>、<code>pading</code>、<code>border</code>都预置为0，然后<code>position:absolute；</code>定位，在浏览器F12下查看这两个伪元素，很正常，宽高0 × 0，没有占据任何空间。然而，当我把鼠标移动到距离触发hover的区域还有一段距离时，hover就触发了。这很诡异！</p><p>虽然暂时不知道为啥，不过解决办法还是有的。直接给<code>.wrap</code>添加<code>overflow: hidden;</code>，然后新增一个<code>:hover</code></p><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">overflow</span>: visible;&#125;</code></pre><p>道理很简单。直接把超出的内容(目前不清楚是啥，估计就那两个伪元素)给去掉，这样就不会影响<code>:hover</code>的作用范围了。等到触发<code>:hover</code>后再给它显示出来。</p><h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><p>观察了好一会儿才发现，是伪元素<code>content</code>的问题。即便我把宽高设置为0，文字依旧会显示(<code>overflow</code>的问题)，如图。因为原来设置的字体颜色是白色。。所以一直没发现问题…..</p><p><img src="https://img-blog.csdnimg.cn/20201203105945156.png" alt="在这里插入图片描述"></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>知道问题根源后，解决就很简单了</p><p>想到两个办法</p><ol><li><p>给<code>.wrap:after</code>添加<code>overflow: hidden;</code></p><p><a href="https://codepen.io/litstronger/pen/GRjpzay">演示地址</a></p></li><li><p>在<code>.wrap:after</code>里设置<code>font-size:0;</code>，在<code>.wrap:after</code>里设置<code>font-size:1em;</code></p><p>这个改起来也简单，就不搞了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题 css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js判断浮点数相等</title>
    <link href="/2020/11/30/interview/js%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E7%AD%89/"/>
    <url>/2020/11/30/interview/js%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<p>某2020前端互助群的每周议题(三)  Part 1</p><a id="more"></a><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><ol><li>非是<code>ECMAScript</code> 独有，基于<code>IEEE754 </code>设计的语言都有这个毛病，如<code>C</code>和<code>Java</code></li><li><code>IEEE754</code> 标准中 64 位的储存格式，比如 11 位存偏移值</li><li>其中涉及的三次精度丢失<ul><li>使用浮点数表示0.1</li><li>使用浮点数表示0.2</li><li>使用浮点数表示运算后(0.1+0.2)的值</li></ul></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li><p>toFixed() + parseFloat()</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>num 待处理的数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>len 小数点后保留位数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">epsEqu</span>(<span class="hljs-params">num, len = <span class="hljs-number">10</span></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(num.toFixed(len))&#125;<span class="hljs-built_in">console</span>.log(epsEqu(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>) === <span class="hljs-number">0.3</span>) <span class="hljs-comment">// true</span></code></pre></li></ol><ol start="2"><li><p>toPrecision() + parseFloat()</p><p>注意与toFixed的细微差别(参数范围)</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>num 待处理的数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>len 返回的浮点数位数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">epsEqu</span>(<span class="hljs-params">num, len = <span class="hljs-number">10</span></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(num.toPrecision(len))&#125;<span class="hljs-built_in">console</span>.log(epsEqu(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>) === <span class="hljs-number">0.3</span>) <span class="hljs-comment">// true</span></code></pre></li><li><p>利用<code>Number.EPSILON</code></p><p>MDN解释</p><blockquote><p><strong>Number.EPSILON</strong> 属性表示 1 与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>可表示的大于 1 的最小的浮点数之间的差值。</p><p>你不必创建一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a> 对象来访问这个静态属性（直接使用 <code>Number.EPSILON</code>）。</p></blockquote><p><code>EPSILON</code> 属性的值接近于 <code>2.2204460492503130808472633361816E-16</code>，或者 <code>2-52。</code></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">epsEqu</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(a - b) &lt; <span class="hljs-built_in">Number</span>.EPSILON ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>&#125;<span class="hljs-built_in">console</span>.log(epsEqu(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)) <span class="hljs-comment">// true</span></code></pre><p>然后。。。这个方法有缺点</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(epsEqu(<span class="hljs-number">1.1</span> + <span class="hljs-number">1.3</span>, <span class="hljs-number">2.4</span>)) <span class="hljs-comment">// false</span></code></pre></li><li><p>处理浮点数运算的库：<a href="https://github.com/josdejong/mathjs"><code>math.js</code></a></p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/mqyqingfeng/frontend-interview-question-and-answer/issues/10">[未知]如何判断 0.1 + 0.2 与 0.3 相等？ #10</a></p><p><a href="https://github.com/zhangxinxu/quiz/issues/74">JS基础测试47期 #74</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">Number.EPSILON</a></p><p><a href="https://www.html.cn/archives/7340">JavaScript 浮点数运算的精度问题</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js程序执行顺序判断</title>
    <link href="/2020/11/26/js%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/"/>
    <url>/2020/11/26/js%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>某2020前端互助群的每周议题(二)</p><a id="more"></a><p><strong>参考学习资料:</strong></p><p><a href="https://es6.ruanyifeng.com/#docs/promise#Promise-prototype-catch">《ECMAScript 6 入门》Promise </a></p><p><a href="https://es6.ruanyifeng.com/#docs/async">《ECMAScript 6 入门》async </a></p><p><a href="https://www.yuque.com/kuwu/opfh8y/kriyta">本次议题总结</a></p><p><strong>题目:</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">await</span> async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">3</span>&#125; <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;, <span class="hljs-number">0</span>); async1().then(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(v)) <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);    resolve();    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);&#125;); <span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>);</code></pre><p><strong>我的思路：</strong></p><p>按照正常顺序，首先遇到的是宏任务<code>setTimeout()</code>，将其加入<code>宏任务队列</code>（稍后执行）<br>代码继续运行，进入函数<code>async1()</code>，直接输出1，</p><pre><code class="hljs shell">1</code></pre><p>执行函数<code>async2()</code>，直接输出4</p><pre><code class="hljs shell">1 4</code></pre><p>然后遇到了微任务<code>await async2()</code>，将其加入<code>微任务队列</code>(稍后执行)，<code>await async2()</code>后的代码将被阻塞直到该微任务执行完</p><p>接着进入<code>Promise()</code>，直接输出6。</p><pre><code class="hljs shell">1 4 6</code></pre><p>然后遇到了<code>resolve()</code>，将其加入<code>微任务队列</code>，接着是输出7</p><pre><code class="hljs shell">1 4 6 7</code></pre><p>代码继续执行，直接输出9</p><pre><code class="hljs shell">1 4 6 7 9</code></pre><hr><p>至此代码已经执行到末尾了，开始执行微任务队列中的任务。<br>根据队列 <strong>先进先出</strong> 的特点，可以知道先执行<code>await async2()</code>，直接输出4，微任务完成</p><pre><code class="hljs shell">1 4 6 7 9</code></pre><p>接着执行之前之前被阻塞的部分，直接输出2，然后遇到微任务<code>await 3</code>，将其加入<code>微任务队列</code>，后续代码进入阻塞状态</p><pre><code class="hljs shell">1 4 6 7 9 2</code></pre><p>从微任务队列中取出前面加入的<code>resolve()</code>，执行后进入.then()，直接输出8，微任务完成</p><pre><code class="hljs shell">1 4 6 7 9 2 8</code></pre><p>从微任务队列中取出剩下的微任务<code>await 3</code>， 微任务完成。返回值为3，然后进入.then()，输出3</p><pre><code class="hljs shell">1 4 6 7 9 2 8 3</code></pre><p>所有微任务都执行完后，就剩下宏任务<code>setTimeout</code>了，执行任务，输出5</p><pre><code class="hljs shell">1 4 6 7 9 2 8 3 5</code></pre><hr><p><a href="">为了更好地理解本次内容，咕咕侠决定手写一个极其简陋的<code>Promise</code>，并且实现ES2021引入的Promise.any()方法，篇幅较长，另开文章</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js判断数据类型</title>
    <link href="/2020/11/26/js%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/11/26/js%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>某2020前端互助群的每周议题(一)</p><a id="more"></a><p><a href="https://juejin.cn/post/6897214524912074766/">议题内容引自</a></p><h2 id="1-JavaScript中判断数据类型"><a href="#1-JavaScript中判断数据类型" class="headerlink" title="1. JavaScript中判断数据类型"></a>1. JavaScript中判断数据类型</h2><p>首先我来表演个js魔法</p><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>    <span class="hljs-comment">// Object -- null的类型是Object</span><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false  -- null不是Object的实例 </span></code></pre><p>精彩！（掌声） 那么，为啥呢？</p><p> 原因是null不是一个空引用, 而是一个原始值, 参考<a href="https://link.zhihu.com/?target=http://lzw.me/pages/ecmascript/%2320">ECMAScript5.1中文版</a> 4.3.11节; 它只是期望此处将引用一个对象, 注意是”期望”, 参考 <a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null">null - JavaScript</a>. （<a href="https://www.zhihu.com/question/21691758">引自知乎</a>）</p><p>既然是原始值，那么，怎么解释<code>typeof null</code>的结果为Object呢，MDN是这么解释的</p><blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。（<a href="http://www.2ality.com/2013/10/typeof-null.html">参考来源</a>）</p><p>曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但<a href="http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null">被拒绝了</a>。该提案会导致 <code>typeof null === &#39;null&#39;</code></p></blockquote><p>魔法结束，聊聊正经的</p><h3 id="1-常见需要判断的数据类型"><a href="#1-常见需要判断的数据类型" class="headerlink" title="1. 常见需要判断的数据类型"></a>1. 常见需要判断的数据类型</h3><p><strong>基本类型：</strong>String、Number、Boolean、undefined、null、Symbol(ES6引入)</p><p><strong>进阶类型：</strong>Function、Array、Object、NaN、空值等</p><h3 id="2-类型判断方案"><a href="#2-类型判断方案" class="headerlink" title="2. 类型判断方案"></a>2. 类型判断方案</h3><p><strong>2.1 typeof</strong></p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>); <span class="hljs-comment">// &quot;number&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>); <span class="hljs-comment">// &quot;boolean&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// &quot;undefined&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">Symbol</span>())) <span class="hljs-comment">// &quot;symbol&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>) <span class="hljs-comment">// &quot;number&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []) <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)) <span class="hljs-comment">// &quot;function&quot;</span></code></pre><p>在对<code>null</code>，<code>NaN</code>，<code>[]</code>的判断上没有得到理想的结果，typeof无法做到完全区分类型</p><ul><li>number: 会受到NaN的干扰，很多场景其实判断number类型是想要判断是合理的数字类型</li><li>null: 历史遗留的bug了</li><li>数组会被判别为Object: 这样就无法区分Array和Object了</li></ul><p><strong>2.2 Object.prototype.toString()</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">varType</span>(<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj)&#125;<span class="hljs-built_in">console</span>.log(varType(<span class="hljs-string">&quot;1&quot;</span>)); <span class="hljs-comment">// &quot;[object String]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-number">1</span>)); <span class="hljs-comment">// &quot;[object Number]&quot;</span><span class="hljs-built_in">console</span>.log(varType(&#123;&#125;)); <span class="hljs-comment">// &quot;[object Object]&quot;</span><span class="hljs-built_in">console</span>.log(varType([])); <span class="hljs-comment">// &quot;[object Array]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;)); <span class="hljs-comment">// &quot;[object Function]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// &quot;[object Null]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// &quot;[object Number]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-built_in">Symbol</span>())); <span class="hljs-comment">// &quot;[object Symbol]&quot;</span><span class="hljs-built_in">console</span>.log(varType(<span class="hljs-built_in">RegExp</span>())); <span class="hljs-comment">// &quot;[object RegExp]&quot;</span></code></pre><p>可见除了NaN以外，其他类型都能判断，以字符串<code>[object &lt;类型&gt;]</code>的格式输出结果</p><blockquote><p>ps：除了使用<code>call()</code>之外，也可以使用<code>apply</code>，唯一的区别是二者接接受的参数格式不同，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">详见</a></p></blockquote><p>对NaN的处理可以使用函数<code>isNaN()</code></p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>))  <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">1</span>))  <span class="hljs-comment">// false</span></code></pre><p>进行把<code>varType()</code>封装一层如下，这样就可以拿来用了</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> isTypeOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">`[object <span class="hljs-subst">$&#123;type&#125;</span>]`</span> === <span class="hljs-built_in">Object</span>.prototype.toString.call(obj)    &#125;&#125;<span class="hljs-comment">// 箭头函数形式</span><span class="hljs-keyword">var</span> isTypeOf = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> <span class="hljs-string">`[object <span class="hljs-subst">$&#123;type&#125;</span>]`</span> === <span class="hljs-built_in">Object</span>.prototype.toString.call(obj)<span class="hljs-comment">// 测试</span><span class="hljs-built_in">console</span>.log(isTypeOf(<span class="hljs-string">&quot;Array&quot;</span>)([])) <span class="hljs-comment">// true</span></code></pre><h3 id="3-判断数组"><a href="#3-判断数组" class="headerlink" title="3. 判断数组"></a>3. 判断数组</h3><p><strong>3.1 instanceof</strong> </p><p><code>[] instanceof Array</code>看看是否为Array的实例。不过有个坑，instanceof实际上是根据原型链上的继承关系来判断的，而Array继承自Object，因此会有 <code>[] instanceof Object</code>结果为<code>true</code>的情况。</p><p><strong>3.2 constructor</strong></p><p>通过目标的构造器来判断就不会出现<code>instanceof</code>里的意外结果</p><pre><code class="hljs js">[].constructor === <span class="hljs-built_in">Array</span>  <span class="hljs-comment">// true</span>[].constructor === <span class="hljs-built_in">Object</span>  <span class="hljs-comment">// false</span></code></pre><p><strong>3.3 Array.isArray()</strong></p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.isArray([])  <span class="hljs-comment">// true</span></code></pre><p><strong>3.4 采用前文提及的toString()方法</strong></p><h3 id="4-空值判断"><a href="#4-空值判断" class="headerlink" title="4. 空值判断"></a>4. 空值判断</h3><p><strong>4.1 null:</strong><code>Object.prototype.toString.apply(null) === &quot;[object Null]&quot; </code>(或者用call调用也一样的)</p><p><strong>4.2 undefined:</strong><code>typeof undefined === undefined</code>,  <code>typeof undefine === null</code>(false,严格比较不会进行数据转换)</p><p>**4.3 Array:**先判断是否为数组, 再判断<code>length</code>是否为0。（直接判断length为0不合理，存在<a href="https://blog.csdn.net/weixin_42505098/article/details/82820063">类数组</a>）</p><p>**4.4 Object:**场景不多，群友给出了一个想法 <code>Object.getOwnPropertyNames</code> 判断返回的数组中属性的个数</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写js轮子</title>
    <link href="/2020/11/26/%E6%89%8B%E5%86%99js%E8%BD%AE%E5%AD%90/"/>
    <url>/2020/11/26/%E6%89%8B%E5%86%99js%E8%BD%AE%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>为了更好地理解一些js方法的原理，决定自己捏捏轮子</p><a id="more"></a><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h1><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;    <span class="hljs-keyword">const</span> newThis = args[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span>;    <span class="hljs-keyword">const</span> realArgs = args.slice(<span class="hljs-number">1</span>);    <span class="hljs-keyword">const</span> func = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">const</span> funcSym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;func&#x27;</span>);  <span class="hljs-comment">// 创建临时函数</span>    newThis[funcSym] = func;    <span class="hljs-keyword">const</span> res = newThis[funcSym](...realArgs);  <span class="hljs-comment">// 执行</span>        <span class="hljs-keyword">delete</span> newThis.funcSym;  <span class="hljs-comment">// 删除</span>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回执行值</span>&#125;</code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p><code>apply()</code>与<code>call()</code>之间除了接收的参数不同，可以说没有其他区别。因此大致的实现是和<code>call()</code>一样的，除了在处理接收到参数方面点区别，这里就不贴了。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p><code>bind()</code>是ES5引入的函数。<code>bind()</code>与<code>call()</code>的区别在于它不会立即执行函数，而是返回一个修改了<code>this</code>的新函数，执行需要调用该新函数。</p><p>前面已经实现了<code>call()</code>, 这里就直接借用<code>call()</code>来实现了。</p><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;        <span class="hljs-keyword">const</span> newThis = args[<span class="hljs-number">0</span>];    <span class="hljs-keyword">const</span> realArgs = args.slice(<span class="hljs-number">1</span>);    <span class="hljs-keyword">const</span> func = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>)</span>&#123;        <span class="hljs-keyword">return</span>  func.call(newThis, ...realArgs, ...newArgs)    &#125;&#125;</code></pre><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise极简"><a href="#Promise极简" class="headerlink" title="Promise极简"></a>Promise极简</h2><p>1.实现了基本的异步、回调功能。(then和catch)</p><p>2.未实现链式调用，如<code>.then().catch()</code></p><hr><p><code>Promise()</code>的参数是一个带有<code>resolve</code>和<code>reject</code>两个参数的函数，据此我们可以先抽象出MyPromise的结构</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;    <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-comment">// 把resolve()和reject()绑定到当前对象，也就是令二者的this值指向MyPromise的实例</span>    executor(resolve.bind(<span class="hljs-built_in">this</span>), reject.bind(<span class="hljs-built_in">this</span>))     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">params</span>) </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">error</span>) </span>&#123;&#125;&#125;MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;&#125;</code></pre><p>实现<code>resolve()</code>,<code>rejected()</code>和<code>then()</code></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;    <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;pending&quot;</span>    <span class="hljs-built_in">this</span>.successCallback = <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// &#x27;fulfilled&#x27;时调用的函数，在then()中赋值</span>    <span class="hljs-built_in">this</span>.failCallback = <span class="hljs-literal">undefined</span><span class="hljs-comment">// &#x27;rejected&#x27;时调用的函数，在then()/catch()中赋值</span>    executor(resolve.bind(<span class="hljs-built_in">this</span>), reject.bind(<span class="hljs-built_in">this</span>))    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">params</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>)&#123;            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 使用setTimeout的宏任务队列模拟微任务队列</span>                <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;fulfilled&quot;</span>                <span class="hljs-built_in">this</span>.successCallback(params)            &#125;, <span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">error</span>) </span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span></span>)</span>&#123;            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 同上</span>                <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;rejected&quot;</span>                <span class="hljs-built_in">this</span>.failCallback(error)            &#125;, <span class="hljs-number">0</span>);        &#125;    &#125;&#125;MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">this</span>.successCallback = resolve    <span class="hljs-built_in">this</span>.failCallback = reject&#125;MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reject</span>) </span>&#123;    <span class="hljs-built_in">this</span>.failCallback = reject&#125;</code></pre><p><strong>测试</strong></p><pre><code class="hljs js"><span class="hljs-comment">/* then */</span><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)    resolve(<span class="hljs-number">2</span>)            <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))  <span class="hljs-comment">// 输出 1 3 2</span><span class="hljs-comment">/* catch */</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-1&quot;</span>) &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span>, err))  <span class="hljs-comment">// 输出 err: err-1</span></code></pre><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>虽然说我们无法使用<code>.then().catch()</code>这种链式调用来捕获错误，但实际上<code>then()</code>本身就可以捕获错误了(利用第二个参数<code>reject</code>)，因此实现<code>MyPromise.any()</code>这里我就只使用<code>then()</code></p><pre><code class="hljs js"><span class="hljs-comment">/* ES2021 引入any()概念 */</span> MyPromise.any = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> isFulfilled = <span class="hljs-literal">false</span>        <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>        <span class="hljs-keyword">let</span> AggregateError = [] <span class="hljs-comment">// 收集错误</span>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">of</span> list) &#123;              i.then(  <span class="hljs-comment">// then(resolve, reject)  </span>                (value) =&gt; &#123;                            <span class="hljs-keyword">if</span> (!isFulfilled) &#123;                        isFulfilled = <span class="hljs-literal">true</span>                        resolve(value)  <span class="hljs-comment">// 以第一个&#x27;fulfilled&#x27;的Promise实例作为返回值</span>                    &#125;                &#125;,                (error) =&gt; &#123;                     len++                    AggregateError.push(error)                    <span class="hljs-keyword">if</span> (len === list.length) &#123;    <span class="hljs-comment">//所有的promise都reject了</span>                        reject(AggregateError)                    &#125;                &#125;            )        &#125;    &#125;)&#125;</code></pre><p><strong>测试</strong></p><pre><code class="hljs js"><span class="hljs-comment">/* 存在fulfilled的Promise实例 */</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-1&quot;</span>)&#125;)<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-2&quot;</span>)&#125;)<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    resolve(<span class="hljs-number">3</span>)&#125;)<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> MyPromise.any([p1, p2, p3]).then(    (v) =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;any:&quot;</span>, v)    &#125;,    (err) =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;any-err&quot;</span>, err)    &#125;)<span class="hljs-comment">// 输出：any: 3</span><span class="hljs-comment">/* Primise实例全部rejected */</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-1&quot;</span>)&#125;)<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-2&quot;</span>)&#125;)<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(<span class="hljs-string">&quot;err-3&quot;</span>)&#125;)<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> MyPromise.any([p1, p2, p3]).then(    (v) =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;any:&quot;</span>, v)    &#125;,    (err) =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;any-err&quot;</span>, err)    &#125;)<span class="hljs-comment">// 输出：any-err [ &#x27;err-1&#x27;, &#x27;err-2&#x27;, &#x27;err-3&#x27; ]</span></code></pre><hr><p>还有一个神奇的实现思路是利用Promise.all()。把所有<code>Promise</code>实例(包括<code>Promise.all()</code>本身)的<code>resolve</code> 和 <code>reject</code>参数位置交换一下，这样就可以把<code>all()</code>转换成<code>any()</code>了。这是利用了和<code>any()</code>和<code>all()</code>二者存在类似于<code>与</code>和<code>或</code>的关系(数电学过吧)，因此把<code>all()</code>的逻辑取反就得到了<code>any()</code>，代码如下(这个是网上抄的，我找不到原文了)</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span> (<span class="hljs-params">promise</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(      (resolve, reject) =&gt; <span class="hljs-built_in">Promise</span>.resolve(promise).then(reject, resolve))  &#125;    MyPromise.any = <span class="hljs-function">(<span class="hljs-params">iterable</span>) =&gt;</span>    reverse(<span class="hljs-built_in">Promise</span>.all([...iterable].map(reverse)))</code></pre><p><strong>测试</strong></p><pre><code class="hljs js">MyPromise.any([  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;✗&#x27;</span>),  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;✗&#x27;</span>),  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;✓&#x27;</span>),]).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-comment">// value is &#x27;✓&#x27; </span>&#125;);MyPromise.any([  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;✗&#x27;</span>),  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;✗&#x27;</span>),]).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reasons</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(reasons)  <span class="hljs-comment">// reasons is [&#x27;✗&#x27;, &#x27;✗&#x27;] </span>&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAI笔记</title>
    <link href="/2020/11/16/SAI%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/11/16/SAI%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>摸鱼日常</p><a id="more"></a><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>Ctrl</code> + <code>z</code></p><p><code>Ctrl</code> + <code>s</code></p><p><code>Ctrl</code> + <code>+</code> 放大画布</p><p><code>Ctrl</code> + <code>-</code> 缩小画布</p><p><code>H</code> 水平镜像翻转 <code>E</code>橡皮(铅笔N)</p><p><code>shift</code> 两点直线</p><p><code>Ctrl</code> + <code>R</code> 直尺，按主Ctrl可移动尺子，再次使用快捷键则取消</p><p><code>空格</code> + <code>笔/鼠标</code> 移动画布</p><p><code>[</code>, <code>]</code> 笔刷大小</p><p><code>Ctrl</code> + <code>D</code> 取消选区</p><p><code>Ctrl</code> + <code>鼠标点击图层</code> 快速选区</p><p><code>Ctrl</code>+<code>T</code> 在使用套索选中目标后使用该快捷键，可以对其放大缩小</p><p>精化线稿</p><ul><li><p>重： 轮廓  转折</p></li><li><p>轻：内部线条  褶皱</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>摸鱼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板绘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html归档</title>
    <link href="/2020/09/14/html%E5%BD%92%E6%A1%A3/"/>
    <url>/2020/09/14/html%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>本篇为MDN上学习html相关时，对一些生疏点的学习记录。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 接触前端也半年多了，是时候回头看看排查一下了。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-名词释义"><a href="#1-名词释义" class="headerlink" title="1.名词释义"></a>1.名词释义</h2><p><code>href:</code> 超文本引用（ <strong>h</strong>ypertext <strong>ref</strong>erence）。</p><p><code>CSP:</code> content security policy</p><h2 id="2-备忘"><a href="#2-备忘" class="headerlink" title="2.备忘"></a>2.备忘</h2><h3 id="2-1列表"><a href="#2-1列表" class="headerlink" title="2.1列表"></a>2.1列表</h3><p><code>&lt;ol&gt;:</code> order list，有序列表</p><p><code>&lt;ul&gt;:</code></p><h3 id="2-2表格"><a href="#2-2表格" class="headerlink" title="2.2表格"></a>2.2表格</h3><p><code>&lt;td&gt;:</code> table data</p><p><code>&lt;tr&gt;:</code> table row</p><p><code>&lt;th&gt;:</code> table header</p><pre><code class="hljs ht">&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</code></pre><hr><pre><code class="hljs ht">&lt;colgroup&gt;    &lt;col&gt;&lt;col&gt;&lt;colgroup&gt;</code></pre><hr><p>结构布局规范</p><p><code>&lt;thead&gt;</code></p><p><code>&lt;tfoot&gt;</code></p><p><code>&lt;tbody&gt;</code></p><hr><p><code>iframe</code></p><p>安全问题，如<a href="https://blog.csdn.net/qq_32523587/article/details/79613768">点击劫持</a></p><blockquote><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>, </iframe> 或者 <object> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌套到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-fluid归档</title>
    <link href="/2020/09/12/hexo-fluid%E5%BD%92%E6%A1%A3/"/>
    <url>/2020/09/12/hexo-fluid%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>本篇记录使用博客的过程中遇到的一些错误和解决办法</p><a id="more"></a><p><strong>1.从github仓库迁移到服务器上时部分资源加载失败</strong></p><p>把hexo博客迁移到服务器上时，发现部分资源不能加载。控制台报错<code>net::ERR_CONNECTION_CLOSED</code>。这是因为以前配置hexo主题的时候，把所有资源链接都强制升级为https，而我的服务器站点没有配置SSL证书，才会出现这种情况。</p><p>有两个解决办法：</p><ul><li>一是为站点添加SSL证书，</li><li>二是把关闭强制资源链接使用https访问的选项(该选项通常在博客主题里配置)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>彩印机静态网页</title>
    <link href="/2020/09/02/electron%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/09/02/electron%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>开发彩印机项目web静态页面的问题记录。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以以“使用记录”为标题，是因为我觉得我是出于完成任务式地去了解<code>electron</code>这个框架，很多时候甚至官方文档都没咋看，直接在网上找<code>demo</code>套。以至于整个项目下来后，对这个框架并没有比较全面深入的了解，只能说是会用吧。</p><p><strong>体验:</strong> <code>electron</code>本质上是个<code>nodejs</code>应用程序，不同点是它专注于桌面应用，而不是web服务器。有意思的是，它以web页面作为自己的<code>GUI</code>(图形界面)，就像是用javascript控制的一个可魔改的精简浏览器(Chromium )。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-软件"><a href="#1-软件" class="headerlink" title="1.软件"></a>1.软件</h3><p><a href='https://www.electronjs.org/'><span class="label label-success">Electron</span></a> <span class="label label-primary">前端三语言</span></p><h3 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2.硬件"></a>2.硬件</h3><p><a href='https://support.epson.com.cn/setupnavi/?LG2=C2&OSC=WS&MKN=L805&toppage=&PINF=menu/'><span class="label label-primary">EPSON L805</span></a> <span class="label label-warning">树莓派</span> <span class="label label-primary">13.3寸电容屏</span>  <span class="label label-danger">外壳设计</span></p><h3 id="3-问题合集"><a href="#3-问题合集" class="headerlink" title="3.问题合集"></a>3.问题合集</h3><p><strong>1.鼠标点击按钮时正常，触屏点击时出现奇怪的阴影</strong></p><p>网上查了好一会儿，没得到什么有用的信息。</p><p>后来想了想，这种电容屏更多是应用在移动端(<code>ipad</code>、<code>手机</code>等)，于是更换搜索关键字为: <code>移动端</code> <code>点击出现阴影</code> <code>css</code>，很快就找到一些解决方法。</p><p>只需给按钮增加css样式，把点击时的高亮设置为透明</p><pre><code class="hljs css"><span class="hljs-selector-tag">tap-highlight-color</span>: <span class="hljs-selector-tag">rgba</span>(255, 255, 255, 0);<span class="hljs-selector-tag">-webkit-tap-highlight-color</span>: <span class="hljs-selector-tag">rgba</span>(255, 255, 255, 0);<span class="hljs-comment">/*</span><span class="hljs-comment">tap-highlight-color：当用户轻按一个链接或者JavaScript</span><span class="hljs-comment">可点击元素时给元素覆盖一个高亮色如果想取消这个高亮，将值</span><span class="hljs-comment">设置为全透明即可，比如transparent</span><span class="hljs-comment">*/</span></code></pre><p><strong>2.整合静态页面与驱动脚本</strong></p><p>在我这边交互界面(前端)写得差不多后，需要跟后端驱动彩印机(采用的是<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E6%89%93%E5%8D%B0%E5%8D%8F%E8%AE%AE/12714792?fr=aladdin">互联网打印协议(IPP)</a>，使用npm上的<code>ipp</code>模块)的朋友对接一下。当然遇到这么一个问题，从网络上获取到的图片要怎么存放，存放在哪 ?</p><ul><li><p>第一时间的想法是在服务器(树莓派)的后端再开一个接口，用来接收前端得到的图片链接，并把图片下载后暂存在本地，供给后端的朋友调用</p></li><li><p>第一个方法虽然能解决问题，但似乎把问题给复杂化了？前端项目使用了<code>electron</code>框架，其文件<code>main.js</code>是<code>nodejs</code>环境，是可以直接作为后端的啊！于是考虑把朋友那边调用<code>ipp</code>的js代码整合到我的<code>electron</code>项目中，这样一来就不需要下载，仅需把前端获取到的图片文件传递过去，就可以打印了。考虑使用<code>ipcMain</code>模块来把<code>fetch()</code>后再用<code>arrayBuffer()</code>处理的图片传递给后端打印。但是写完后发现，ipcMain不支持该数据格式的拷贝传递。突然翻车。。</p></li><li><p>第三个想法是后来看到html文件中的ipc模块是用<code>require()</code>引入的，才意识到这里的网页上是有<code>nodejs</code>环境的！那就好办了，这还要啥后端，驱动彩印机部分的代码直接写网页上。使用<code>fetch()</code>获取网络图片先转化为<code>arrayBuffer()</code>后传递给<code>ipp</code>模块，驱动彩印机打印图片。</p><p>但到了这里遇到了一个问题：<strong>图片的格式不对。</strong>网上稍微查了下，应该是我错把<code>arrayBuffer</code>当成<code>Buffer</code>了，利用<code>Buffer.from()</code>转化一下即可得到<code>Buffer</code>格式的图片。嗯，就这样，彩印机它突突突地就欢快地跑了起来，没其他问题了。</p><p><strong>后续：</strong></p><p>后来我重新试了下，第二个方法(使用<code>ipcMain</code>传参)其实是可行的，不过需要把图片转化为Buffer格式(前面的尝试过程中报错是因为格式搞错了，arrayBuffer()处理后返回的并不是Buffer)。虽然可以，但没必要，嗯。</p></li></ul><p><strong>3.项目打包发布</strong></p><p>关于打包，此图诚不欺我</p><blockquote><p>意思大概是如果你打算打包你的electron应用程序，你将会有一段艹蛋的时光</p></blockquote><img src="https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/electron/pack.png"/><p>electron<a href="https://www.electronjs.org/docs/tutorial/quick-start#create-a-basic-application">官方文档</a>的例子推荐的工具是electron-forge，刚开始照着文档跑了下，体验不佳。一个是会出现奇怪的现象—-生成的exe会有奇怪的启动画面。另外，程序莫名其妙地被运行了两次，一次是立即执行，另一次是在启动动画之后执行。翻了几遍<a href="https://www.electronforge.io/">electron-forge官方文档</a>，也没有找到任何关于启动时的动画的配置介绍(好吧，我觉得那更像是一个bug，而不是我所想的启动动画，如图)</p><img src="https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/electron/elec_forge.png"/><p>想了好一会，觉得这并不是我这边出的问题，应该是打包工具electron-forge的bug了，另寻他路。在electron文档里看到了electron-builder，这个用起来就感觉挺好的，主要是安装配置遇到了点麻烦。</p><p>关于安装，官网是这么说的</p><blockquote><p><a href="http://yarnpkg.com/">Yarn</a> is <a href="https://github.com/electron-userland/electron-builder/issues/1147#issuecomment-276284477">strongly</a> recommended instead of npm.</p></blockquote><p>啊，我用的是npm，所以踩了一堆坑，以下是我的踩坑表演</p><pre><code class="hljs shell">npm install electron-builder --save-dev</code></pre><p>配置package.json</p><ul><li><p>填入<code>name</code>, <code>description</code>, <code>version</code> 和 <code>author</code>.</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-electron-app&quot;</span>,  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;description&quot;</span>,  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;lyq&quot;</span>&#125;</code></pre></li><li><p>打包的配置。下面是mac和linux的配置，但windows环境下(我win10)并不能生成mac和linux，默认只能生成windows的包…</p><pre><code class="hljs json">&quot;build&quot;: &#123;  &quot;appId&quot;: &quot;your.id&quot;,  &quot;mac&quot;: &#123;    &quot;category&quot;: &quot;your.app.category.type&quot;  &#125;,  &quot;linux&quot;: &#123;    &quot;target&quot;: [      &quot;AppImage&quot;,      <span class="hljs-string">&quot;deb&quot;</span>    ]  &#125;&#125;,</code></pre></li><li><p>添加脚本</p><pre><code class="hljs json">&quot;scripts&quot;: &#123;  &quot;pack&quot;: &quot;electron-builder --dir&quot;,  &quot;dist&quot;: &quot;electron-builder&quot;&#125;</code></pre></li></ul><p>配置好后运行</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run dist</span></code></pre><p>然后会报几个错。告诉你<code>winCodeSign-2.6.0</code>和<code>nsis-3.0.4.1</code>,<code>nsis-resources-3.4.1</code>包rename失败。稍微看了下。它是把包下载下来后再改名的，但没有权限改名(access is denied)。这里我就不太能理解了，我已经给了管理员权限，应该可以改名的啊。</p><img src="https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/electron/rename_err.png"/><p>解决的办法是手动改名。直接打开tempFile的路径，把文件夹<code>181096083</code>改名为<code>winCodeSign-2.6.0</code>。之后会再遇到两次类似的错误，处理办法也是一样的，找到文件，然后改名就行了。</p><p>最后再运行打包命令<code>npm run dist</code>，就成功运行，生成的安装包在dist文件夹下。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>electron文档翻译简中版有挺多小错误的，但当我想参与修正时，发现进入编辑的是beta版本，正式发布的版本与可编辑的版本内容差别很大，连quick start的demo都不一样。阿这….好复杂，算了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>antd使用记录</title>
    <link href="/2020/08/29/ant-design-vue%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/08/29/ant-design-vue%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录使用ant-design-vue开发的流程，以及遇到的错误。</p><a id="more"></a><h2 id="错误合集"><a href="#错误合集" class="headerlink" title="错误合集"></a>错误合集</h2><p>官网没给vue-cli4的例子，于是试试按照官网<a href="https://www.antdv.com/docs/vue/use-with-vue-cli-cn/">vue-cli3的步骤</a>操作，遇到了一些问题，这里记录下，后文给了完整过程，我亲自重新跑过一遍，应该是没有问题的。</p><ul><li>坑1.<br><code>Failed to resolve loader: less-loader You may need to install it.</code></li><li>坑2.<br> <code>error  in ../node_modules/_ant-design-vue@1.6.5@ant-design-vue/es/button/style/index.less  Module build failed (from ./node_modules/less-loader/dist/cjs.js):  // https://github.com/ant-design/ant-motion/issues/44   .bezierEasingMixin();</code></li></ul><h2 id="使用-按需引入"><a href="#使用-按需引入" class="headerlink" title="使用(按需引入)"></a>使用(按需引入)</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><p>安装vue-cli(我现在装的是4.3)</p><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> install -g @vue/cli</code></pre><p>创建项目, 配置可自选，这里我直接回车默认</p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>vue create antd-demo</code></pre><p>运行，访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，可以看到 Welcome to Your Vue.js App </p><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> antd<span class="hljs-literal">-demo</span><span class="hljs-variable">$</span> npm run serve</code></pre><h3 id="2-引入-ant-design-vue"><a href="#2-引入-ant-design-vue" class="headerlink" title="2.引入 ant-design-vue"></a>2.引入 ant-design-vue</h3><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> ant-design-vue</code></pre><p>在main.js中引入Button组件</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>; <span class="hljs-comment">//引入组件，但不用引入样式</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>Vue.component(Button.name, Button); <span class="hljs-comment">//注册</span>Vue.config.productionTip = <span class="hljs-literal">false</span><span class="hljs-keyword">new</span> Vue(&#123;  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre><p>在app.vue里调用Button组件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Vue logo&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/logo.png&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;Welcome to Your Vue.js App&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><h3 id="3-按需引入"><a href="#3-按需引入" class="headerlink" title="3.按需引入"></a>3.按需引入</h3><p>安装babel-plugin-import插件</p><pre><code class="hljs sql">$ npm <span class="hljs-keyword">install</span> babel-<span class="hljs-keyword">plugin</span>-<span class="hljs-keyword">import</span> <span class="hljs-comment">--dev</span></code></pre><p>将配置文件<code>babel.config.js</code>的内容替换为如下</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  presets: [<span class="hljs-string">&quot;@vue/app&quot;</span>],  plugins: [    [      <span class="hljs-string">&quot;import&quot;</span>,      &#123; <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&quot;ant-design-vue&quot;</span>, <span class="hljs-attr">libraryDirectory</span>: <span class="hljs-string">&quot;es&quot;</span>, <span class="hljs-attr">style</span>: <span class="hljs-literal">true</span> &#125;    ]  ]&#125;;</code></pre><p>运行</p><pre><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> serve</span></code></pre><p>报错如下，需要安装<code>less-loader</code></p><p><img src="https://img-blog.csdnimg.cn/20200903121015985.png#pic_center" alt="在这里插入图片描述"></p><p>运行</p><pre><code class="hljs sql">$ npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">less</span>-loader <span class="hljs-comment">--save-dev</span></code></pre><p>然后，它继续报错。还要安装<code>less</code></p><img src='https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/ant-design-vue/2.png'><p>运行</p><pre><code class="hljs sql">$ npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">less</span> <span class="hljs-comment">--save-dev</span></code></pre><p>看样子是<code>less</code>包本身有问题了，它提示给了个Github的<a href="https://github.com/ant-design/ant-motion/issues/44">issues地址</a>，访问看看</p><img src='https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/ant-design-vue/3.png'><p>哇噻，好多大佬遇到了这个问题，翻下去发现各路神仙给了好多解决办法。看了十几个高赞的，大体都是两种办法来解决。</p><p><strong>方法一</strong>：less降级</p><p>但有一些工具是要求用<code>less3.x</code>的(印象中新版webpack就是这样)。算了</p><p><strong>方法二</strong>：<code>less-loader</code>配置里开启允许<code>javascript</code></p><p>这个方法看起来好点，我用的<code>vue-cli4</code>，需要手动在根目录下创建配置文件<code>vue.config.js</code>，在<code>issues</code>评论里找到对应<code>vue-cli4</code>的配置填入。</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  css: &#123;      loaderOptions: &#123;          less: &#123;            lessOptions:&#123;              javascriptEnabled: <span class="hljs-literal">true</span>,            &#125;          &#125;      &#125;  &#125;,&#125;</code></pre><p>ps: 如果没能成功的话，可以试试更多其他版本的配置，详情见<a href="https://github.com/ant-design/ant-motion/issues/44">https://github.com/ant-design/ant-motion/issues/44</a>，本文评论区也有网友给出了其他可用的配置格式</p><p>重新运行，Nice~，按需引入完成。</p><img src='https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/ant-design-vue/6.png'><p>浏览器访问</p><p><img src="https://img-blog.csdnimg.cn/20200903122233151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p>期间还遇到一个小问题，就是import引入时的组件名与实例的标签名并不一致，例如<code>Button</code>组件对应的标签名是<code>AButton</code>如图</p><img src='https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/ant-design-vue/4.png'><img src='https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/ant-design-vue/5.png'><hr><p>附上目前<a href="https://github.com/vueComponent/ant-design-vue/blob/master/components/index.js">所有组件的列表</a></p><p>以上仅是引入一个简单的Button组件，如果要引入官方文档上的Layout示例，那又得踩不少坑，具体见<a href="https://blog.csdn.net/weixin_43641850/article/details/108301690">vue-cli4.0引入官方文档中的Layout示例</a></p><blockquote><p>tip: 如果本篇对你有所帮助，不妨点个赞支持一下~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows归档</title>
    <link href="/2020/08/28/windows%E5%BD%92%E6%A1%A3/"/>
    <url>/2020/08/28/windows%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>windows轻量级的实用/美化工具的合集。</p><a id="more"></a><h2 id="个人桌面"><a href="#个人桌面" class="headerlink" title="个人桌面"></a>个人桌面</h2><div><video width=100% controls>  <source src='https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/windows/desktop.mp4' type='video/mp4'>   <source src='https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/windows/desktop.ogv' type='video/ogg'>   <source src='https://cdn.jsdelivr.net/gh/litstronger/pic@master/post/windows/desktop.webm' type='video/webm'></video>    </div><h3 id="桌面工具"><a href="#桌面工具" class="headerlink" title="桌面工具"></a>桌面工具</h3><p>由于是轻薄本，因此不打算考虑<a href="https://www.baidu.com/link?url=yPh8AMjC22wnkGdZXbaTb8FpYcGHHGFzcsr867HWwqzVe0nLuinOPT53nZ131GymuWILngoMV2qW3MMzZGuIeq&wd=&eqid=9cdfb5d800013689000000045f48cae6"> Wallpaper Engine</a>等比较占资源的美化工具，而是往工具轻量，风格简约的方向优化。</p><ul><li><p><strong>translucentTB</strong></p><p>一个可以修改任务栏样式的轻量软件，大小仅几兆，<a href="https://github.com/TranslucentTB/TranslucentTB">Github项目地址</a></p><p><strong>支持的样式</strong></p><ul><li>Normal(系统默认)</li><li>Clear(全透明)</li><li>Opaque不透明</li><li>Blur(毛玻璃)</li><li>Fluent(液体)</li></ul></li><li><p><strong>Rainmeter</strong></p><p>桌面插件管理器。可以到官网找到很多有趣的小插件，比如上述视频中的左上角的天气插件</p></li></ul><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><p><strong>Everything</strong></p><p>windows蜗牛般的检索速度。真的慢得感人。Everything解决了这一问题，检索极快，快速帮你找到你想要的文件/文件夹。轻便，大小1.4m。还有一个优点是，支持免安装，也就是，你把它放U盘里也可以直接运行使用。<a href="https://www.voidtools.com/zh-cn/">中文官网</a></p></li><li><p><strong>Glary Utilities</strong></p><p>体验非常好的电脑管理工具</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows归档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css随笔</title>
    <link href="/2020/08/25/css%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/08/25/css%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>个人学习css的一些笔记</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>受够了每次改样式都要去找度娘的这件事了，决定开始重视css。明明很多都是以前查过、解决过的问题，隔一段时间就忘了。于是乎，本篇诞生了( 开篇撒花!  ***)</p><h1 id="8-26-CSS动画"><a href="#8-26-CSS动画" class="headerlink" title="8.26 CSS动画"></a>8.26 CSS动画</h1><h2 id="过渡-transition"><a href="#过渡-transition" class="headerlink" title="过渡 transition"></a>过渡 transition</h2><h3 id="1-transition-propety"><a href="#1-transition-propety" class="headerlink" title="1.transition-propety"></a>1.transition-propety</h3><p>列举要设置动画的所有属性，如：<code>left</code>、<code>margin-left</code>、<code>height</code> 和 <code>color</code>。 <a href="http://www.w3.org/TR/css3-transitions/#animatable-properties-">大多数</a>属性都是可以的。<code>all</code> 表示应用在所有属性上。</p><h3 id="2-transition-duration"><a href="#2-transition-duration" class="headerlink" title="2.transition-duration"></a>2.transition-duration</h3><p>动画持续的时间。单位为秒 <code>s</code> 或者毫秒 <code>ms</code></p><h3 id="3-transition-delay"><a href="#3-transition-delay" class="headerlink" title="3.transition-delay"></a>3.transition-delay</h3><p>设定动画延迟开始的时间。可以是负值。那么动画将会从整个过渡的中间时刻开始渲染。例如，对于 <code>transition-duration: 2s</code>，同时把 <code>delay</code> 设置为 <code>-1s</code>，则过渡动画持续 1 秒钟，并且从正中间开始渲染。</p><h3 id="4-transition-timing-function"><a href="#4-transition-timing-function" class="headerlink" title="4.transition-timing-function"></a>4.transition-timing-function</h3><ul><li><p><strong>cubic-bezier</strong></p><p>贝塞尔曲线  <a href="https://zh.javascript.info/bezier-curve">原理</a>(了解)</p><ul><li><p>x表示时间：0为开始，1标志着结束（即对应<code>transition-duration</code>的结束时刻）</p></li><li><p>y表示过程的完成度：0为属性的初始值，1为属性的最终值（即对应属性的新值）</p><p><strong>Tip：</strong> 其实可以用<code>时间-路程</code> (高中物理)模型来理解其坐标图,，曲线的斜率即为速度。因此不难理解贝塞尔曲线的斜率对应的就是属性改变的快慢</p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssNotes/chart.png"/></li></ul><p><strong>cubic-bezier(x2, y2, x3, y3)</strong></p><ul><li><p>接收两个中间点的坐标作为参数（起始和终止点默认为(0,0)，(1,1), 因此总共有4个点来确定曲线)</p><p>注：如果参数只接收到一个点，该属性会失效</p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssNotes/console.png"/></li><li><p>坐标值可以有负值。(类似惯性的现象)</p><p>cubic-bezier(0.5, -1, 0.5, 1.5)</p><p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssNotes/1598405157254.png" alt="1598405157254"></p></li></ul><p>CSS 提供几条内置的曲线：<code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code> 和 <code>ease-in-out</code>。</p><p><code>linear</code> 其实就是 <code>cubic-bezier(0, 0, 1, 1)</code> 的简写，图像是一条斜率不变的直线，</p><p>其它几个的贝塞尔曲线的简写如下：</p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssNotes/otherChart.png"/><p>挂一个能找到合适的贝塞尔曲线的网站：<a href="http://cubic-bezier.com/">http://cubic-bezier.com/</a></p></li></ul><h3 id="5-transitionend事件"><a href="#5-transitionend事件" class="headerlink" title="5.transitionend事件"></a>5.transitionend事件</h3><p>CSS 动画完成后，会触发 <code>transitionend</code> 事件，可用HTML DOM的<code>addEventListener(event, function)</code>进行捕捉</p><h3 id="6-Keyframes-关键帧动画"><a href="#6-Keyframes-关键帧动画" class="headerlink" title="6.Keyframes 关键帧动画"></a>6.Keyframes 关键帧动画</h3><p>这个也有好多参数哎哟我去..</p><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><blockquote><p>一切皆盒子</p></blockquote><h2 id="1-CSS选择器"><a href="#1-CSS选择器" class="headerlink" title="1.CSS选择器"></a>1.CSS选择器</h2><h3 id="1-1-选择器类型"><a href="#1-1-选择器类型" class="headerlink" title="1.1 选择器类型"></a>1.1 选择器类型</h3><ul><li>行内选择器：<code>style=&quot;&quot;</code></li><li>ID选择器：<code>#my-id</code>…</li><li>class选择器：<code>.my-class</code>…</li><li>标签名样式：<code>div</code>, <code>img</code>, <code>title</code> …</li><li>伪类：<ul><li>简单伪类：<code>:first-child</code>, <code>:last-child</code>，<code>:nth-of-type(n)</code>…</li><li>用户行为伪类：<code>:hover</code>, <code>:focus</code>, <code>:touch</code>…</li></ul></li><li>伪元素：<code>::before</code>, <code>::after</code>，<code>::first-line</code>，<code>::first-letter</code>…</li></ul><p>此外，还有<strong>属性选择器</strong>等等，更多详情请参阅 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors">选择器</a>…</p><blockquote><p>nth-of-type()中的nth并不是什么单词的缩写，<a href="https://zhidao.baidu.com/question/427311487.html">详见</a></p></blockquote><h3 id="1-2-优先级"><a href="#1-2-优先级" class="headerlink" title="1.2 优先级"></a>1.2 优先级</h3><ul><li><p>如果一个容器被多条css语句定义，优先顺序为：<strong>行内样式</strong> &gt; <strong>ID选择器</strong> &gt; <strong>类(class)选择器</strong> &gt; <strong>标签名样式</strong></p><p>不难发现，约束越严格，优先级越高</p></li><li><p><code>! important</code>，可以更改CSS样式优先级，<strong>使该条样式属性声明具有最高优先级。</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">box</span>&#123;<span class="hljs-attribute">color</span>:red <span class="hljs-meta">!important</span>;&#125;</code></pre></li></ul><h2 id="2-盒模型"><a href="#2-盒模型" class="headerlink" title="2.盒模型"></a>2.盒模型</h2><h3 id="2-1-块级、内联"><a href="#2-1-块级、内联" class="headerlink" title="2.1 块级、内联"></a>2.1 块级、内联</h3><ul><li>块级(block)：<code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>…</li><li>内联(inline)：<code>&lt;a&gt;</code>,<code>&lt;span&gt;</code>…</li><li>inline-block：通常用于不希望目标换行，但需要设定宽高的情况</li></ul><p><strong>盒模型</strong></p><p>默认情况下，块级元素的宽度是父元素的100％，高度与本身内容一样。</p><ul><li><p>Content box 内容</p></li><li><p>Padding box 内边距 </p></li><li><p>Border box 边宽</p></li><li><p>Margin box 外边距</p><p>父子关系</p><ol><li><p>垂直方向上，margin-top/margin-bottom设置为auto时，自动计算为0，因此不能实现垂直居中</p></li><li><p>父元素高度设置为auto时，父元素将以子元素上下边框的距离作为自身高度。</p><p>若是父元素设置了上/下内边距，或者是上/下边框，那么将以子元素的上下外边距间的距离作为高度</p><blockquote><p>tip: width,height未设置时都是auto</p></blockquote></li></ol></li></ul><p>完整的css盒模型应用于块级盒子，内联元素仅使用盒模型的部分定义</p><p><strong>替代盒模型</strong></p><ul><li><p>标准模型(默认)：width = <code>content</code>, 这里的width只是内容的宽度，不是实际宽度</p></li><li><p>替代模型：width = <code>content</code>+ <code>border</code> + <code>padding</code></p><p>设置：<code>box-sizing: border-box</code> 。如果你希望所有盒模型都使用替代模型，只需</p><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>&#123;    <span class="hljs-attribute">box-sizing</span>: border-box;&#125;</code></pre></li></ul><h2 id="3-文本"><a href="#3-文本" class="headerlink" title="3.文本"></a>3.文本</h2><p><strong>匿名文本：</strong>指所有未包含在行内元素中的字符串</p><p><strong>em框：</strong>高度由当前的font-size确定</p><p><strong>内容区：</strong>简单起见以em框定义，注意替换元素还需加上边框(border)、内边距(padding)</p><p><strong>行间距：</strong>只应用于非替换蒜素，<code>line-height</code> - <code>font-size</code>,实际上得到的值还需要分成两半(半间距)，应用到内容区的顶部和底部</p><p><strong>常见属性：</strong></p><p><strong>text-indent</strong> 缩进</p><p><strong>text-align</strong> 对齐方式</p><p><strong>line-height</strong> 行高，行基线之间的距离。因为默认会继承该属性，通常不给单位会好些，会自动按块字体的大小缩放</p><p><strong>vertical-align</strong> 垂直对齐文本。只应用于行内元素和替换元素</p><p><strong>word-spacing</strong> 单词间隔</p><p><strong>letter-spacing</strong> 字母间隔</p><p><strong>text-transform</strong> 文本转换，大小写、首字母等</p><p><strong>text-decoration</strong> 文本装饰，上、下划线，贯穿线等</p><p><strong>text-shadow</strong> 文本阴影</p><p><strong>direction</strong> 文本方向</p><p><strong>样式化链接</strong></p><ul><li><p>Link 未访问</p></li><li><p>Visited 已访问</p></li><li><p>Hover 光标停留</p></li><li><p>Focus 被选中(如使用键盘tab</p></li><li><p>Active 链接激活后</p><p>注意顺序：<strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p></li></ul><h2 id="4-布局"><a href="#4-布局" class="headerlink" title="4.布局"></a>4.布局</h2><h3 id="1-flex"><a href="#1-flex" class="headerlink" title="1.flex"></a>1.flex</h3><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法。</p><p><img src="https://developer.mozilla.org/files/3739/flex_terms.png" alt="flex_terms.png"></p><ul><li>main axis 主轴</li><li>cross axis 交叉轴</li></ul><p>常用属性</p><ul><li><p>flex-direction 确定主轴方向</p></li><li><p>flex-wrap 换行</p></li><li><p>flex 常用例子如下：</p><p><code>flex: 200px</code>，则宽度至少为<code>200px</code></p><p><code>flex: 1</code>，无单位的比例，动态尺寸，如有两个元素该值都设为1，则各占50%可用的空间</p></li><li><p>flex-flow <code>flex-direction</code>和<code>flex-wrap</code>的缩写</p><pre><code class="hljs css"><span class="hljs-selector-tag">flex-direction</span>: <span class="hljs-selector-tag">row</span>;<span class="hljs-selector-tag">flex-wrap</span>: <span class="hljs-selector-tag">wrap</span>;</code></pre><p>等价于</p><pre><code class="hljs css"><span class="hljs-selector-tag">flex-flow</span>: <span class="hljs-selector-tag">row</span> <span class="hljs-selector-tag">wrap</span>;</code></pre></li><li><p>order 元素排序，默认值为0，越大越靠后，可以是负值。例如将第一个按钮移到末尾</p><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first-child</span> &#123;  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;&#125;</code></pre></li><li><p>justify-content: 控制元素在主轴的位置</p></li><li><p>align-items: 控制元素在交叉轴的位置</p></li></ul><p>flex全写</p><ul><li>flex-grow  即前文提到的无单位比例</li><li>flex-shrink  处理溢出项这个是进阶用法，暂不研究</li><li>flex-basis 即前文提到的元素最小值</li></ul><h3 id="2-grid-网格"><a href="#2-grid-网格" class="headerlink" title="2.grid(网格)"></a>2.grid(网格)</h3><p>网格是由一系列水平及垂直的线构成的以一种布局模式。</p><ul><li>column 列</li><li>row 行</li><li>gutter 沟槽(间隙)</li></ul><p>常用单位: <code>fr</code></p><p>网格间隙</p><ul><li><p>grid-column-gap 列间隙</p></li><li><p>grid-row-gap 行间隙</p></li><li><p>grid-gap 同时定义行列间隙</p><p>后来标准把前缀grid-去除，改成gap</p></li></ul><p>重复构建行/列：repeat</p><p>显式网格与隐式网格（懵）</p><p>大小限制：minmax()</p><p>自动填充：auto-fill</p><p>基于线的元素放置</p><ul><li>grid-column 基于<code>grid-column-start</code>,<code>grid-column-end</code>的缩写</li><li>grid-row 基于<code>gird-row-start</code>和<code>gird-row-end</code>的缩写</li></ul><p>基于<code>grid-template-areas</code>属性的元素放置</p><ul><li>需要填满网格的每个格子</li><li>一个连续的区域必须是一个矩形</li><li>格子留空时使用<code>.</code>占位</li></ul><h3 id="3-浮动"><a href="#3-浮动" class="headerlink" title="3.浮动"></a>3.浮动</h3><p>需要注意的应该就是浮动导致的<strong>高度计算</strong>问题了。</p><p>使用了float属性后，自身会脱离文档流(也就是在文档流中高度为0)，因此可能会出现以下情况</p><ul><li><p>外部包裹的盒子没有撑开，如下图的蓝色框</p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssNotes/float.png"/></li><li><p>浮动元素下方的盒子元素<code>block</code>使用margin-top会失效</p><p>带有float属性的元素在文档流中高度为0，因此会出现意料之外的情况</p></li></ul><p><strong>解决办法：</strong>清除浮动。在使用了float属性的元素后添加一个盒子(如div)，再添加css属性<code>clear</code>即可</p><h3 id="4-定位"><a href="#4-定位" class="headerlink" title="4.定位"></a>4.定位</h3><p><strong>文档流</strong></p><p><strong>static：</strong>占据正常的文档流，浏览器默认</p><p><strong>relative：</strong>占据正常的文档流，在不改变文档流的情况下移动元素（通过<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>）</p><p><strong>absolute：</strong>脱离正常的文档流，不占据文档流空间。常用于：<code>弹出信息框</code>，<code>控制菜单</code>，<code>翻转面板</code>，以及可以在页面上的任何地方拖放的<code>UI功能</code>……</p><ul><li><p>上下文：<code>top</code>，<code>left</code>等属性都需要有一个参考对象。通常是选取离得最近、并且有显示定义<code>position</code>属性(非默认<code>static</code>)的父元素。</p><p>**更改上下文： **如将参考对象更改为父元素<code>&lt;div&gt;</code>，可在父元素中设置<code>position</code>属性即可实现</p><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">relative</span>;</code></pre></li></ul><ul><li><p>z-index：调整重叠的<code>absolute</code>的堆叠顺序，默认值为0，数值越大越靠前</p></li><li><p>可实现绝对定位的垂直居中</p><p>在子元素中使用<code>top:0</code>，<code>bottom:0</code>后再使用<code>margin: auto,0</code>即可实现，详情见《css权威指南第三版》p331</p></li></ul><p><strong>fixed：</strong>绝对定位的工作方式完全相同，只有一个主要区别：绝对定位固定元素是相对于<html>元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身常用于顶部导航菜单</p><p><strong>sticky：</strong>可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部。蛮有意思的</p><h3 id="5-多列布局"><a href="#5-多列布局" class="headerlink" title="5.多列布局"></a>5.多列布局</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p><strong>column-count：</strong>列数</p><p><strong>column-width：</strong>列宽</p><h4 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h4><p><strong>column-gap：</strong>列间间隙</p><p><strong>column-rule：</strong>列间添加分割线，线利用的是gap的空间(不占宽度)</p><p><strong>break-inside：</strong>选择<code>avoid</code>时，可以避免列中内容(如文段)被分割成两部分</p><h3 id="6-响应式设计"><a href="#6-响应式设计" class="headerlink" title="6.响应式设计"></a>6.响应式设计</h3><h4 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h4><p>viewport。因为移动端常会谎报设备的视口宽度。如480px的设备可能会将视口宽度设为960px，这会导致你的媒体查询失效。因此需要加入下述内容</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></code></pre><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>最简单的语法</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-feature-rule)&#123;    <span class="hljs-comment">/* css rule go here */</span>&#125;</code></pre><p>例如，在<code>width</code>小于400px时把字体改成蓝色</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">400px</span>)&#123;    <span class="hljs-selector-tag">body</span>&#123;        <span class="hljs-attribute">color</span>: blue;    &#125;&#125;</code></pre><h4 id="Flexible-grid"><a href="#Flexible-grid" class="headerlink" title="Flexible grid"></a>Flexible grid</h4><p>使用灵活的网格，就不必再免去适配各种宽度的设备。</p><blockquote><p>早期用于实现响应式布局的只有<code>float</code>，通常是让每一个元素都带有百分比，并且总和不超过100%，以实现适应各种宽度的屏幕</p></blockquote><h4 id="Modern-layout-technologies"><a href="#Modern-layout-technologies" class="headerlink" title="Modern layout technologies"></a>Modern layout technologies</h4><p><strong>多列布局</strong>(Multiple-column layout)，<strong>弹性布局</strong>(Flexbox)，<strong>网格布局</strong>(Grid)等….相比起以前只有<code>float</code>，要方便得多了</p><h3 id="7-支持旧浏览器"><a href="#7-支持旧浏览器" class="headerlink" title="7.支持旧浏览器"></a>7.支持旧浏览器</h3><h4 id="构建回滚"><a href="#构建回滚" class="headerlink" title="构建回滚"></a>构建回滚</h4><p>传统的布局(如float)会被grid布局覆盖掉。因此可通过同时给出这两种布局的实现来支持旧浏览器</p><h4 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h4><p><strong>inline-block</strong>：可被flex和grid布局覆盖</p><p><strong>table：</strong>暂时没用过</p><p><strong>Multiple-column Layout(多列布局)</strong></p><p><strong>flex</strong>：可被grid布局覆盖</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>布局相关的属性可以覆盖，但像<code>width</code>等的属性可能会影响结果。比如在grid布局和float布局中都对宽度进行了一些限制，那么float中的对<code>width</code>限制会影响grid中的设定</p><p><strong>解决办法：</strong>特性查询</p><p>检测当前环境是否支持grid，然后在实施一些相应的操作</p><pre><code class="hljs css"><span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">display:</span> grid) &#123;    <span class="hljs-selector-class">.item</span>&#123;        <span class="hljs-attribute">width</span>: auto; <span class="hljs-comment">/* 重新设置相关属性覆盖float的影响 */</span>    &#125;&#125;</code></pre><h4 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h4><p>flex在对一系列元素排列时，对间隙的控制很有限。我甚至找不到相关属性，目前了解到的只有<code>justify-content: space-around</code>或者是<code>justify-content: space-between</code></p><p>而grid的话，有gap属性，感觉好用点</p><h1 id="杂记-暂不归类"><a href="#杂记-暂不归类" class="headerlink" title="杂记(暂不归类"></a>杂记(暂不归类</h1><p>盒模型</p><ul><li>padding</li><li>border</li><li>margin</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS-肥宅快乐盒</title>
    <link href="/2020/08/15/CSS-%E8%82%A5%E5%AE%85%E5%BF%AB%E4%B9%90%E7%9B%92/"/>
    <url>/2020/08/15/CSS-%E8%82%A5%E5%AE%85%E5%BF%AB%E4%B9%90%E7%9B%92/</url>
    
    <content type="html"><![CDATA[<p>先来看看这个肥宅盒子的效果</p><style>        .wrap{            width: 100px;            height: 100px;            margin: 150px;            position: relative;        }        .cube{              width: 100px;            height: 100px;            margin: 0 auto;            transform-style: preserve-3d;            transform: rotateX(45deg) rotateY(45deg);            animation: motion linear 20s infinite        }        @keyframes motion {            from {                transform: rotateX(0deg) rotateY(0deg);            }            to {                transform: rotateX(360deg) rotateY(360deg);            }        }        .cube .out{            display: block;            position: absolute;            width: 200px;            height: 200px;            opacity: 0.8;            /* hover过渡时间 */            transition: all 0.4s;        }        .pic {            width: 200px;            height: 200px;        }        /* 内部小正方体 */        .cube .in {            display: block;            width: 100px;            height: 100px;            position: absolute;            top: 50px;            left: 50px;        }        .cube .in_pic {            width: 100px;            height: 100px;        }        .cube .front_in {            /* 沿Z轴平移（前移，面向你自己）50px，旋转0° */            transform: rotateY(0deg) translateZ(50px);        }        .cube .back_in {            /* 后移50px，旋转0° */            transform: rotateY(180deg) translateZ(50px);        }        .cube .left_in {            /* 沿X轴平移（左移）50px，绕Y轴顺时针旋转90° */            transform: rotateY(90deg) translateZ(50px) ;        }        .cube .right_in {            /* 右移50px，绕Y轴逆时针旋转90° */            transform: rotateY(-90deg) translateZ(50px);        }        .cube .top_in {            /* 沿Z轴（上移）50px，绕Y轴顺时针旋转90° */            transform: rotateX(90deg) translateZ(50px);        }        .cube .bottom_in {            /* 下移50px，绕Y轴逆时针旋转90° */            transform: rotateX(-90deg) translateZ(50px);        }        .cube .front_out {            /* 沿Z轴平移（前移，面向你自己）50px，旋转0° */            transform: rotateY(0deg) translateZ(100px);        }        .cube .back_out {            /* 后移50px，旋转0° */            transform: rotateY(180deg) translateZ(100px);        }        .cube .left_out {            /* 沿X轴平移（左移）50px，绕Y轴顺时针旋转90° */            transform: rotateY(90deg) translateZ(100px) ;        }        .cube .right_out {            /* 右移50px，绕Y轴逆时针旋转90° */            transform: rotateY(-90deg) translateZ(100px);        }        .cube .top_out {            /* 沿Z轴（上移）50px，绕Y轴顺时针旋转90° */            transform: rotateX(90deg) translateZ(100px);        }        .cube .bottom_out {            /* 下移50px，绕Y轴逆时针旋转90° */            transform: rotateX(-90deg) translateZ(100px);        }        /* hover */        .cube:hover .front_out {            transform: rotateY(0deg) translateZ(200px);        }        .cube:hover .back_out {            transform: rotateY(180deg) translateZ(200px);        }        .cube:hover .left_out {            transform: rotateY(90deg) translateZ(200px) ;        }        .cube:hover .right_out {            transform: rotateY(-90deg) translateZ(200px);        }        .cube:hover .top_out {            transform: rotateX(90deg) translateZ(200px);        }        .cube:hover .bottom_out {            transform: rotateX(-90deg) translateZ(200px);        }</style><div class="wrap">        <div class="cube">            <span class="front_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0eef73838.jpg" class="pic" />            </span>            <span class="back_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0f2fb9a83.jpg" class="pic" />            </span>            <span class="left_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0f55411f0.jpg" class="pic" />            </span>            <span class="right_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0f79a1124.jpg" class="pic" />            </span>            <span class="top_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0f98a8b66.jpg" class="pic" />            </span>            <span class="bottom_out out">                <img src="https://i.loli.net/2018/05/03/5aeb0fdd51b7e.jpg" class="pic" />            </span>            <span class="front_in in">                <img src="https://i.loli.net/2018/05/03/5aeb100223dd0.jpg" class="in_pic" />            </span>            <span class="back_in in">                 <img src="https://i.loli.net/2018/05/03/5aeb101c2c24b.jpg" class="in_pic" />            </span>            <span class="left_in in">                <img src="https://i.loli.net/2018/05/03/5aeb1038127b5.jpg" class="in_pic" />            </span>            <span class="right_in in">                <img src="https://i.loli.net/2018/05/03/5aeb0dce1ca55.jpg" class="in_pic" />            </span>            <span class="top_in in">                <img src="https://i.loli.net/2018/05/03/5aeb1057bb167.jpg" class="in_pic" />            </span>            <span class="bottom_in in">                <img src="https://i.loli.net/2018/05/03/5aeb107514579.jpg" class="in_pic" />            </span>        </div>    </div><p>怎么样，是不是很有意思呢？制作起来其实也不是很难的, 一步一步来</p><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><h3 id="1-1-定位容器"><a href="#1-1-定位容器" class="headerlink" title="1.1 定位容器"></a>1.1 定位容器</h3><p>首先我们需要一个容器（wrap）来确定肥宅盒子在浏览器中的位置（为了节省空间已省略部分html）</p><p><img src="https://img-blog.csdnimg.cn/20200815231750710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="灰色部分"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.wrap</span>&#123;</span>    width: 100px;    height: 100px;    margin: 150px auto;<span class="css">    <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-tag">gray</span>;<span class="hljs-comment">/* 方便观察div位置 */</span></span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="1-2-承载容器"><a href="#1-2-承载容器" class="headerlink" title="1.2 承载容器"></a>1.2 承载容器</h3><p>在容器wrap里还需要加一个用于承载正方体的容器（cube）。打个比喻，有点像是器皿的底座这样子</p><p><img src="https://img-blog.csdnimg.cn/20200815232750746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="绿色部分"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.wrap</span>&#123;</span>    width: 100px;    height: 100px;    margin: 150px auto;    position: relative;    background: gray;&#125;<span class="css"><span class="hljs-selector-class">.cube</span>&#123;</span>    width: 50px;    height: 50px;    margin: 0 auto;<span class="css">    <span class="hljs-selector-tag">background</span><span class="hljs-selector-pseudo">:greenyellow</span>;</span>    transform-style: preserve-3d; &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cube&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>好的，我们的底座已经完成了，是时候实现一个立体的小正方体了。</p><h2 id="2-小正方体"><a href="#2-小正方体" class="headerlink" title="2.小正方体"></a>2.小正方体</h2><h3 id="2-1-引入图片"><a href="#2-1-引入图片" class="headerlink" title="2.1 引入图片"></a>2.1 引入图片</h3><p>首先引入6张图片作为6个面（由于重叠，引入后暂时只能看到一张图片），并设定大小</p><p><img src="https://img-blog.csdnimg.cn/20200816012906990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="效果"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-comment">/* 内部小正方体表面 */</span></span><span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.in</span> &#123;</span>    display: block;    width: 100px;    height: 100px;    position: absolute;    top: 50px;    left: 50px;&#125;<span class="css"><span class="hljs-comment">/* 表面图片 */</span></span><span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.in_pic</span> &#123;</span>    width: 100px;    height: 100px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cube&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;front_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/1.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/2.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/3.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/4.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/5.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom_in in&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/6.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="2-2-立体构建"><a href="#2-2-立体构建" class="headerlink" title="2.2 立体构建"></a>2.2 立体构建</h3><p>接下来我们让每个面都旋转、移动到正确的位置。为每个面添加css</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-comment">/* 每个面都有自己的坐标轴XYZ，参考高考的几何题 */</span></span><span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.front_in</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 绕自身Y轴旋转0°, 再沿Z轴平移50px */</span></span>    transform: rotateY(0deg) translateZ(50px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.back_in</span> &#123;</span>    transform: rotateY(180deg) translateZ(50px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.left_in</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 绕自身Y轴旋转90°，再沿Z轴平移50px */</span></span>    transform: rotateY(90deg) translateZ(50px) ;&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.right_in</span> &#123;</span>    transform: rotateY(-90deg) translateZ(50px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.top_in</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 绕自身Y轴旋转90°，再沿Z轴平移 */</span></span>    transform: rotateX(90deg) translateZ(50px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.bottom_in</span> &#123;</span>    transform: rotateX(-90deg) translateZ(50px);&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h3 id="2-3-倾斜"><a href="#2-3-倾斜" class="headerlink" title="2.3 倾斜"></a>2.3 倾斜</h3><p>由于我们是从正面看过去的，所以目前还是只能看到一个面，只需要给底座.cube添加一个倾斜角度就可以看到立体的正方体了</p><pre><code class="hljs css"><span class="hljs-selector-class">.cube</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">background</span>:greenyellow;    <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>); <span class="hljs-comment">/* 倾斜角度 */</span>&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200816013320139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="倾斜后的立体效果"></p><h2 id="3-大正方体"><a href="#3-大正方体" class="headerlink" title="3. 大正方体"></a>3. 大正方体</h2><h3 id="3-1-立体样式-图片"><a href="#3-1-立体样式-图片" class="headerlink" title="3.1 立体样式+图片"></a>3.1 立体样式+图片</h3><p>搞出小正方体后，同理可实现外部的大正方体, 对应的css如下</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-comment">/* 外部正方体 */</span></span><span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.out</span>&#123;</span>    display: block;    position: absolute;    width: 200px;    height: 200px;<span class="css">    <span class="hljs-selector-tag">opacity</span>: 0<span class="hljs-selector-class">.8</span>;</span><span class="css">    <span class="hljs-comment">/* hover过渡时间 */</span></span><span class="css">    <span class="hljs-selector-tag">transition</span>: <span class="hljs-selector-tag">all</span> 0<span class="hljs-selector-class">.4s</span>;</span>&#125;<span class="css"><span class="hljs-comment">/* 外部正方体表面图片 */</span></span><span class="css"><span class="hljs-selector-class">.pic</span> &#123;</span>    width: 200px;    height: 200px;&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.front_out</span> &#123;</span>    transform: rotateY(0deg) translateZ(100px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.back_out</span> &#123;</span>    transform: rotateY(180deg) translateZ(100px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.left_out</span> &#123;</span>    transform: rotateY(90deg) translateZ(100px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.right_out</span> &#123;</span>    transform: rotateY(-90deg) translateZ(100px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.top_out</span> &#123;</span>    transform: rotateX(90deg) translateZ(100px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.bottom_out</span> &#123;</span>    transform: rotateX(-90deg) translateZ(100px);&#125;    <span class="css"><span class="hljs-comment">/* 鼠标悬浮(hover)时撑开各个面的效果 */</span></span><span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.front_out</span> &#123;</span>    transform: rotateY(0deg) translateZ(200px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.back_out</span> &#123;</span>    transform: rotateY(180deg) translateZ(200px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.left_out</span> &#123;</span>    transform: rotateY(90deg) translateZ(200px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.right_out</span> &#123;</span>    transform: rotateY(-90deg) translateZ(200px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.top_out</span> &#123;</span>    transform: rotateX(90deg) translateZ(200px);&#125;<span class="css"><span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.bottom_out</span> &#123;</span>    transform: rotateX(-90deg) translateZ(200px);&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>引入外部表面6张图片</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 外部正方体 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;front_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0eef73838.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0f2fb9a83.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0f55411f0.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0f79a1124.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0f98a8b66.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom_out out&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://i.loli.net/2018/05/03/5aeb0fdd51b7e.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200816003908645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="外部正方体"></p><p><img src="https://img-blog.csdnimg.cn/20200816005949302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="鼠标悬浮效果"></p><p>到这里就已经大致完成了！最后还需要让这个正方体旋转起来，也很简单</p><h3 id="3-2-自动旋转"><a href="#3-2-自动旋转" class="headerlink" title="3.2 自动旋转"></a>3.2 自动旋转</h3><p>在容器.cube中添加对应的css样式，如下</p><pre><code class="hljs css"><span class="hljs-comment">/* 定义名为motion动画，绕X轴和Y轴旋转360° */</span><span class="hljs-keyword">@keyframes</span> motion &#123;    <span class="hljs-selector-tag">from</span> &#123;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);    &#125;    <span class="hljs-selector-tag">to</span> &#123;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">360deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">360deg</span>);    &#125; &#125;<span class="hljs-selector-class">.cube</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">background</span>:greenyellow;    <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>); <span class="hljs-comment">/* 倾斜角度 */</span><span class="hljs-attribute">animation</span>: motion linear <span class="hljs-number">20s</span> infinite;  <span class="hljs-comment">/* 添加名为motion的动画,循环执行动画 */</span>&#125;</code></pre><h2 id="4-完结撒花"><a href="#4-完结撒花" class="headerlink" title="4.完结撒花"></a>4.完结撒花</h2><p>最后的最后，把我们前面在容器.wrap和.cube添加的背景颜色去掉(即删掉下面两行)</p><pre><code class="hljs scss"><span class="hljs-attribute">background</span>: gray;   <span class="hljs-comment">/* .wrap */</span><span class="hljs-attribute">background</span>: greenyellow;<span class="hljs-comment">/* .cube */</span></code></pre><p>ok，大功告成。平时并没有存图习惯，图片是临时在P站随便找的，可以自行更换自己喜欢的图片，效果更好（带背景色的图片观感更佳）</p><style>        .wrap {            width: 100px;            height: 100px;            margin: 150px auto;            position: relative;        }        .cube {            width: 50px;            height: 50px;            margin: 0 auto;            transform-style: preserve-3d;            transform: rotateX(45deg) rotateY(45deg);            animation: motion linear 20s infinite;            /* 添加名为motion的动画 */        }        @keyframes motion {            from {                transform: rotateX(0deg) rotateY(0deg);            }            to {                transform: rotateX(360deg) rotateY(360deg);            }        }        /* 内部小正方体 */        .cube .in {            display: block;            width: 100px;            height: 100px;            position: absolute;            top: 50px;            left: 50px;        }        /* 小正方体表面图片 */        .cube .in_pic {            width: 100px;            height: 100px;        }        .cube .front_in {            transform: rotateY(0deg) translateZ(50px);        }        .cube .back_in {            transform: rotateY(180deg) translateZ(50px);        }        .cube .left_in {            transform: rotateY(90deg) translateZ(50px);        }        .cube .right_in {            transform: rotateY(-90deg) translateZ(50px);        }        .cube .top_in {            transform: rotateX(90deg) translateZ(50px);        }        .cube .bottom_in {            transform: rotateX(-90deg) translateZ(50px);        }        /* 外部正方体 */        .cube .out {            display: block;            position: absolute;            width: 200px;            height: 200px;            opacity: 0.8;            /* hover过渡时间 */            transition: all 0.4s;        }        /* 外部正方体表面图片 */        .pic {            width: 200px;            height: 200px;        }        .cube .front_out {            transform: rotateY(0deg) translateZ(100px);        }        .cube .back_out {            transform: rotateY(180deg) translateZ(100px);        }        .cube .left_out {            transform: rotateY(90deg) translateZ(100px);        }        .cube .right_out {            transform: rotateY(-90deg) translateZ(100px);        }        .cube .top_out {            transform: rotateX(90deg) translateZ(100px);        }        .cube .bottom_out {            transform: rotateX(-90deg) translateZ(100px);        }        /* 鼠标悬浮hover撑开 */        .cube:hover .front_out {            transform: rotateY(0deg) translateZ(200px);        }        .cube:hover .back_out {            transform: rotateY(180deg) translateZ(200px);        }        .cube:hover .left_out {            transform: rotateY(90deg) translateZ(200px);        }        .cube:hover .right_out {            transform: rotateY(-90deg) translateZ(200px);        }        .cube:hover .top_out {            transform: rotateX(90deg) translateZ(200px);        }        .cube:hover .bottom_out {            transform: rotateX(-90deg) translateZ(200px);        }</style>    <div class="wrap">        <div class="cube">            <!-- 内部正方体 -->            <span class="front_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/1.png" class="in_pic" />            </span>            <span class="back_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/2.png" class="in_pic" />            </span>            <span class="left_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/3.png" class="in_pic" />            </span>            <span class="right_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/4.png" class="in_pic" />            </span>            <span class="top_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/5.png" class="in_pic" />            </span>            <span class="bottom_in in">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/6.png" class="in_pic" />            </span>            <!-- 外部正方体 -->            <span class="front_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/1.png" class="pic" />            </span>            <span class="back_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/2.png" class="pic" />            </span>            <span class="left_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/3.png" class="pic" />            </span>            <span class="right_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/4.png" class="pic" />            </span>            <span class="top_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/5.png" class="pic" />            </span>            <span class="bottom_out out">                <img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/6.png" class="pic" />            </span>        </div></div><h2 id="5-完整实例代码"><a href="#5-完整实例代码" class="headerlink" title="5.完整实例代码"></a>5.完整实例代码</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.wrap</span> &#123;</span>            width: 100px;            height: 100px;            margin: 150px auto;            position: relative;        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> &#123;</span>            width: 50px;            height: 50px;            margin: 0 auto;            transform-style: preserve-3d;            transform: rotateX(45deg) rotateY(45deg);            animation: motion linear 20s infinite;<span class="css">            <span class="hljs-comment">/* 添加名为motion的动画 */</span></span>        &#125;<span class="css">        <span class="hljs-keyword">@keyframes</span> motion &#123;</span>            from &#123;                transform: rotateX(0deg) rotateY(0deg);            &#125;            to &#123;                transform: rotateX(360deg) rotateY(360deg);            &#125;        &#125;<span class="css">        <span class="hljs-comment">/* 内部小正方体 */</span></span><span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.in</span> &#123;</span>            display: block;            width: 100px;            height: 100px;            position: absolute;            top: 50px;            left: 50px;        &#125;<span class="css">        <span class="hljs-comment">/* 小正方体表面图片 */</span></span><span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.in_pic</span> &#123;</span>            width: 100px;            height: 100px;        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.front_in</span> &#123;</span>            transform: rotateY(0deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.back_in</span> &#123;</span>            transform: rotateY(180deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.left_in</span> &#123;</span>            transform: rotateY(90deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.right_in</span> &#123;</span>            transform: rotateY(-90deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.top_in</span> &#123;</span>            transform: rotateX(90deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.bottom_in</span> &#123;</span>            transform: rotateX(-90deg) translateZ(50px);        &#125;<span class="css">        <span class="hljs-comment">/* 外部正方体 */</span></span><span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.out</span> &#123;</span>            display: block;            position: absolute;            width: 200px;            height: 200px;<span class="css">            <span class="hljs-selector-tag">opacity</span>: 0<span class="hljs-selector-class">.8</span>;</span><span class="css">            <span class="hljs-comment">/* hover过渡时间 */</span></span><span class="css">            <span class="hljs-selector-tag">transition</span>: <span class="hljs-selector-tag">all</span> 0<span class="hljs-selector-class">.4s</span>;</span>        &#125;<span class="css">        <span class="hljs-comment">/* 外部正方体表面图片 */</span></span><span class="css">        <span class="hljs-selector-class">.pic</span> &#123;</span>            width: 200px;            height: 200px;        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.front_out</span> &#123;</span>            transform: rotateY(0deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.back_out</span> &#123;</span>            transform: rotateY(180deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.left_out</span> &#123;</span>            transform: rotateY(90deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.right_out</span> &#123;</span>            transform: rotateY(-90deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.top_out</span> &#123;</span>            transform: rotateX(90deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span> <span class="hljs-selector-class">.bottom_out</span> &#123;</span>            transform: rotateX(-90deg) translateZ(100px);        &#125;<span class="css">        <span class="hljs-comment">/* 鼠标悬浮hover撑开 */</span></span><span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.front_out</span> &#123;</span>            transform: rotateY(0deg) translateZ(200px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.back_out</span> &#123;</span>            transform: rotateY(180deg) translateZ(200px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.left_out</span> &#123;</span>            transform: rotateY(90deg) translateZ(200px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.right_out</span> &#123;</span>            transform: rotateY(-90deg) translateZ(200px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.top_out</span> &#123;</span>            transform: rotateX(90deg) translateZ(200px);        &#125;<span class="css">        <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.bottom_out</span> &#123;</span>            transform: rotateX(-90deg) translateZ(200px);        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cube&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 内部正方体 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;front_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/1.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/2.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/3.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/4.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/5.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom_in in&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/6.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;in_pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                        <span class="hljs-comment">&lt;!-- 外部正方体 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;front_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/1.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/2.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/3.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/4.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/5.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom_out out&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/cssBox/6.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>参考文章: <a href="https://cloud.tencent.com/developer/article/1584279">https://cloud.tencent.com/developer/article/1584279</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue随笔</title>
    <link href="/2020/07/22/vue%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/07/22/vue%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h6 id="1-缩写"><a href="#1-缩写" class="headerlink" title="1.缩写"></a>1.缩写</h6><ul><li><p>v-bind</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整写法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span></code></pre></li><li><p>v-on</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整写法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js随笔</title>
    <link href="/2020/07/21/js%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/07/21/js%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>注：全片并未按照一定的顺序编辑，而是仅是相对无序的知识点的整理，参见目录</p><a id="more"></a><h2 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h2><p>通常用于遍历对象</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (variable <span class="hljs-keyword">in</span> object)    statement</code></pre><p>当然，js中数组也是一种特殊的对象，因此<code>for-in</code>也可以像枚举对象属性一样枚举数组索引。但某些浏览器的实现就比较坑了，比如<code>ie</code>，它会把数组原型的一些属性(函数名)也给遍历出来，如<code>map</code>，<code>find</code>，<code>forEach</code>等。</p><p>ie</p><p><img src="https://img-blog.csdnimg.cn/20201213102444444.png" alt="在这里插入图片描述"></p><p>而chrome和edge的实现则比较友好</p><p><img src="C:/Users/lyq/AppData/Roaming/Typora/typora-user-images/1607826464980.png" alt="1607826464980"></p><p>通常来说上述<strong>ie</strong>的情况不是我们希望遇到的，所以嘛，遍历数组还是用原生的<code>for</code>或着<code>forEach()</code>好一点</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><a href="this%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%95%A5%EF%BC%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%81">this到底指向啥？看完这篇就知道了！</a></p><p>修改函数this指向: <code>call()</code>,<code>apply()</code>,<code>bind()</code> <a href="https://liaoyq.club/2020/11/26/%E6%89%8B%E5%86%99js%E8%BD%AE%E5%AD%90/#call-apply-bind">手写实现</a></p><p>js中函数也是对象，因此在使用this时要注意作用域问题。如vue-cli3下，在methods中写多层嵌套函数时，内层函数使用this时会获取不到vue的实例变量。目前暂时想到的解决办法有两种吧</p><ul><li>利用临时变量暂存, 然后进行参数传递，这里传的是引用（或者说类似于指针），因此可以对原变量进行修改</li><li>使用箭头函数，箭头函数内部的this指向的是外层对象（特殊性）</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;    value: <span class="hljs-number">1</span>&#125;methods: &#123;    <span class="hljs-function"><span class="hljs-title">Func1</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value) <span class="hljs-comment">// 1</span>    <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// undefine</span>        &#125;    &#125;&#125;<span class="hljs-comment">// 临时变量 + 传参</span>methods: &#123;    <span class="hljs-function"><span class="hljs-title">Func1</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">this</span>.value    <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params">value</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">// 1</span>        &#125;    &#125;&#125;<span class="hljs-comment">// 箭头函数 关于箭头函数，MDN上是这么解释的</span><span class="hljs-comment">/* 箭头函数表达式的语法比函数表达式更简洁，并且没有自</span><span class="hljs-comment">己的this，arguments，super或new.target。箭头函数</span><span class="hljs-comment">表达式更适用于那些本来需要匿名函数的地方，并且它不能用</span><span class="hljs-comment">作构造函数。*/</span>methods: &#123;    <span class="hljs-function"><span class="hljs-title">Func1</span>(<span class="hljs-params"></span>)</span>&#123;        ()=&gt;&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value) <span class="hljs-comment">// 1</span>        &#125;    &#125;&#125;</code></pre><h2 id="7-22-数组"><a href="#7-22-数组" class="headerlink" title="7.22 数组"></a>7.22 数组</h2><p>虽然经常用js，但其实很多基本操作都不是很熟悉，比如对数组的操作..</p><ul><li><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>slice( start, end )  </p><p>切片，不会修改原数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment">// [ 2, 3, 4 ]</span><span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ], slice()操作不会修改原数组</span></code></pre></li><li><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice( index, howmany, newItem1, … , newItemX )  </p><p>剪切（若有newItem参数则会替换剪切部分），会修改原数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr.splice(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)) <span class="hljs-comment">// [3], 返回剪切掉的部分</span><span class="hljs-built_in">console</span>.log(arr)   <span class="hljs-comment">// [ 1, 2, 6, 4, 5 ], 替换</span></code></pre></li><li><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter( function( currentValue, index, arr), thisValue )</p><ul><li><p>function(必须)，数组中的每个元素都会执行这个函数，如果返回值为 true时最终保留该元素；</p></li><li><p>currentValue(必须)，代表当前元素的值。</p></li><li><p>不会改变原始数组</p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">arr, item</span>) </span>&#123;    <span class="hljs-keyword">let</span> myArr = arr.filter(<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;        <span class="hljs-keyword">return</span> e != item    &#125;)    <span class="hljs-keyword">return</span> myArr&#125;<span class="hljs-built_in">console</span>.log(remove(arr, <span class="hljs-number">2</span>))<span class="hljs-comment">// [1, 3, 4]</span><span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">// [1, 2, 3, 4, 2]</span></code></pre></li><li><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>forEach( function(currentValue, index, arr ), thisValue)</p><ul><li><p>currentValue(必须): 当前元素</p></li><li><p>index: 当前元素的索引值</p></li><li><p>arr: 当前元素所属的数组对象</p></li><li><p>thisValue: 传递给function的”this”的值. 默认下会传递undefined(但我在nodejs下和chrome测试默认情况均不是undefined，奇怪)</p><p> 注：如果回调函数使用了箭头函数，那么thisValue是无效的(箭头函数没有自己的this值)</p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>]arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, index, myarr</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(e)   <span class="hljs-comment">// 6 4</span>    <span class="hljs-built_in">console</span>.log(index)   <span class="hljs-comment">// 0 1</span>    <span class="hljs-built_in">console</span>.log(myarr)   <span class="hljs-comment">// [ 6, 4 ] </span>    <span class="hljs-built_in">console</span>.log(myarr === arr) <span class="hljs-comment">// true  可见传递的时原数组的引用，可以用myarr修改原数组</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)     <span class="hljs-comment">// &#123; str: &#x27;test&#x27; &#125;</span>&#125;, &#123;<span class="hljs-attr">str</span>: <span class="hljs-string">&quot;test&quot;</span>&#125;)<span class="hljs-comment">/*Array、Object用typeof()函数返回值都为object，区分不了是否是数组类型*/</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> arr)    <span class="hljs-comment">// object</span></code></pre></li><li><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort() 排序</p><pre><code class="hljs javascript"><span class="hljs-comment">/* </span><span class="hljs-comment">sort()</span><span class="hljs-comment">    1.会改变原数组</span><span class="hljs-comment">    2.排序规则是根据unicode编码表，逐位比较</span><span class="hljs-comment">    3.默认升序</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<span class="hljs-keyword">var</span> result = arr.sort();<span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ] 返回排序后的数组</span><span class="hljs-built_in">console</span>.log(arr)    <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ] 原数组会被改变</span><span class="hljs-comment">// 逐位比较</span><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<span class="hljs-built_in">console</span>.log(arr1.sort())<span class="hljs-comment">// [ &#x27;aa&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">22</span>, <span class="hljs-number">1</span>]<span class="hljs-built_in">console</span>.log(arr2.sort())<span class="hljs-comment">// [ 1, 22, 3, 4 ] 一位一位地比较，因此这里22在3的前面  </span></code></pre><p>如果想按照数值来排序，则需要给sort()传入一个比较函数compareFn(一个回调函数)</p><pre><code class="hljs javascript"><span class="hljs-comment">// 可以接收参数</span><span class="hljs-comment">/* 注意，不同浏览器对sort的传参顺序可能不同</span><span class="hljs-comment">   比如chrome下是a=4 b=6,火狐下是a=6,b=4</span><span class="hljs-comment">   问题不大，不会影响排序结果*/</span> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>]<span class="hljs-keyword">var</span> result = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a=&#x27;</span>, a)<span class="hljs-comment">// 4</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b=&#x27;</span>, b)<span class="hljs-comment">// 6 </span>&#125;)<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<span class="hljs-keyword">var</span> result = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a=&#x27;</span>, a)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b=&#x27;</span>, b)&#125;)<span class="hljs-comment">// a= 4</span><span class="hljs-comment">// b= 6</span><span class="hljs-comment">// a= 2</span><span class="hljs-comment">// b= 4</span></code></pre><p>虽然各个浏览器采用的排序算法不一样，但有一点是一样的</p><ul><li>比较函数返回a-b: 对应升序</li><li>比较函数返回b-a: 对应降序</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 升序排序</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">var</span> result = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> a-b&#125;)<span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// [ 3, 4, 6, 22 ]</span></code></pre></li><li><h3 id="push-pop"><a href="#push-pop" class="headerlink" title="push(), pop()"></a>push(), pop()</h3><p>push(), pop()  向原数组末尾插入/删除元素(栈的入栈和出栈)</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr.push(<span class="hljs-number">6</span>)) <span class="hljs-comment">// 6，返回值是新数组的长度</span><span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">//[ 1, 2, 3, 4, 5, 6 ]</span><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-built_in">console</span>.log(arr2.pop()) <span class="hljs-comment">// 5，删除数组末尾元素，返回值是被删除的元素</span><span class="hljs-built_in">console</span>.log(arr2)    <span class="hljs-comment">// [1,2,3,4]</span></code></pre></li><li><h3 id="shift-unshift"><a href="#shift-unshift" class="headerlink" title="shift(), unshift()"></a>shift(), unshift()</h3><pre><code class="hljs javascript"><span class="hljs-comment">// shift() 删除并返回数组的第一个元素</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-built_in">console</span>.log(arr.shift()) <span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">//[ 2, 3 ]</span><span class="hljs-comment">// unshift()向数组开头插入一个或多个元素 </span><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-built_in">console</span>.log(arr2.unshift(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 5</span><span class="hljs-built_in">console</span>.log(arr2.unshift(<span class="hljs-number">6</span>))<span class="hljs-comment">// 6</span><span class="hljs-built_in">console</span>.log(arr2)<span class="hljs-comment">// [ 6, 4, 5, 1, 2, 3 ]</span></code></pre></li><li><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>栈：push()入栈,  pop()出栈</li><li>队列：push()入队,  shift()出队</li></ul></li></ul><h2 id="7-26-闭包（closure）"><a href="#7-26-闭包（closure）" class="headerlink" title="7.26 闭包（closure）"></a>7.26 闭包（closure）</h2><h3 id="1-闭包的特点"><a href="#1-闭包的特点" class="headerlink" title="1.闭包的特点"></a>1.闭包的特点</h3><ul><li>我们在函数外部操作了函数内部的值</li><li>闭包对应的函数中的变量是常驻内存</li></ul><h3 id="2-产生闭包的条件"><a href="#2-产生闭包的条件" class="headerlink" title="2.产生闭包的条件"></a>2.产生闭包的条件</h3><ul><li><p>函数嵌套</p></li><li><p>子函数必须用到了外层函数的变量</p><pre><code class="hljs javascript"><span class="hljs-comment">/* example */</span><span class="hljs-keyword">var</span> fun = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> data = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeData</span>(<span class="hljs-params"></span>)</span>&#123;        data += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> data    &#125;    <span class="hljs-keyword">return</span> changeData&#125;)()<span class="hljs-keyword">var</span> example1 = fun<span class="hljs-built_in">console</span>.log(example1()) <span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(example1()) <span class="hljs-comment">// 2</span></code></pre></li><li><p>无法使用<code>!</code>创建的匿名函数构建闭包</p><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> fun = !<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> data = <span class="hljs-number">1</span>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> data    &#125;    <span class="hljs-keyword">return</span> getData&#125;();<span class="hljs-built_in">console</span>.log(fun)<span class="hljs-comment">// false 感叹号被用作取反运算了。。。。</span><span class="hljs-built_in">console</span>.log(fun())<span class="hljs-comment">// TypeError: fun is not a function</span></code></pre></li></ul><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><ul><li><p>以学生为例</p><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> student = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> data = <span class="hljs-number">1</span>         <span class="hljs-keyword">return</span> &#123;        getData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">return</span> data        &#125;,        setData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>)</span>&#123;            data = newVal        &#125;    &#125;&#125;);<span class="hljs-comment">// 学生 1</span><span class="hljs-keyword">let</span> stu1 = <span class="hljs-keyword">new</span> student()<span class="hljs-built_in">console</span>.log(stu1.getData()) <span class="hljs-comment">// 1</span>stu1.setData(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(stu1.getData()) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 学生 2</span><span class="hljs-keyword">let</span> stu2 = <span class="hljs-keyword">new</span> student()<span class="hljs-built_in">console</span>.log(stu2.getData()) <span class="hljs-comment">// 1</span>stu2.setData(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(stu2.getData()) <span class="hljs-comment">// 3</span><span class="hljs-comment">// ...</span></code></pre></li></ul><ul><li><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>内存泄漏: 内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>上述例子中，变量data是常驻内存，如果使用完后没有及时释放就会造成内存泄漏</p><ul><li><p>解决办法：利用javascript的垃圾回收机制进行回收。只需在使用完data后，把外部调用闭包的变量(引用)都赋值为null，这样changeData就被垃圾回收机制当成垃圾对象进行回收，之后对应的data也会被回收，所占的空间也将被释放</p><pre><code class="hljs javascript">example1 = <span class="hljs-literal">null</span>;</code></pre></li></ul></li></ul><h2 id="7-27-浅拷贝，深拷贝"><a href="#7-27-浅拷贝，深拷贝" class="headerlink" title="7.27 浅拷贝，深拷贝"></a>7.27 <a href="https://blog.csdn.net/weixin_37719279/article/details/81240658?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.compare">浅拷贝，深拷贝</a></h2><p><a href="https://blog.lzwzw.cn/posts/af017481.html">https://blog.lzwzw.cn/posts/af017481.html</a></p><h2 id="7-31-匿名函数"><a href="#7-31-匿名函数" class="headerlink" title="7.31 匿名函数"></a>7.31 匿名函数</h2><p>三种写法：</p><ul><li><p>使用！开头。</p><p>!function(形参)(实参)  </p><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单得匿名函数eg：</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_data</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(_data)&#125;</code></pre><p>上述操作并没有执行该函数，要执行该函数只需要在末尾加上括号</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Anonymous&quot;</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_data</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(_data)&#125;(data)<span class="hljs-comment">// Anonymous</span></code></pre></li><li><p>使用()将函数及函数后的括号包裹</p><p>( function() ()) ;</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Anonymous&quot;</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_data</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(_data)&#125;(data))<span class="hljs-comment">// Anonymous</span></code></pre></li><li><p>使用()包裹函数值</p><p>（function())()</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Anonymous&quot;</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_data</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(_data)&#125;)(data)<span class="hljs-comment">// Anonymous</span></code></pre></li></ul><h2 id="8-4-Promise"><a href="#8-4-Promise" class="headerlink" title="8.4 Promise"></a>8.4 Promise</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">MDN上的解释</a></p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，所有错误都可以被后面的<code>catch</code>语句捕获。</p><p>使用示例</p><pre><code class="hljs javascript"><span class="hljs-comment">// nodejs环境下可能需要加上这段，unhandledRejection事件，专门监听未捕获的reject错误</span><span class="hljs-comment">// process.on(&#x27;unhandledRejection&#x27;, (reason, p) =&gt; &#123;</span><span class="hljs-comment">//     console.log(&#x27;Unhandled Rejection at: Promise&#x27;, p, &#x27;reason:&#x27;, reason);</span><span class="hljs-comment">//     // application specific logging, throwing an error, or other logic here</span><span class="hljs-comment">// &#125;);</span><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">data &gt; <span class="hljs-number">0.5</span></span>)</span>&#123;            resolve(<span class="hljs-string">&quot;大于0.5&quot;</span>)        &#125;        <span class="hljs-keyword">else</span>&#123;            reject(<span class="hljs-string">&quot;小于0.5&quot;</span>)        &#125;    &#125;)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo: &quot;</span>, foo)     <span class="hljs-comment">// foo:  [Function: foo]</span><span class="hljs-comment">/*resolve*/</span> foo(<span class="hljs-number">0.7</span>).then(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123; <span class="hljs-comment">// result:  大于0.5</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result: &quot;</span>, result)&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err&quot;</span>, err)&#125;)<span class="hljs-comment">/*reject*/</span>foo(<span class="hljs-number">0.2</span>).then(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;   <span class="hljs-comment">// err: 小于0.5</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result: &quot;</span>, result)&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err: &quot;</span>, err)&#125;)<span class="hljs-comment">/*reject&#x27;冒泡&#x27;性质传递*/</span>foo(<span class="hljs-number">0.1</span>).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123; <span class="hljs-comment">// err:  小于0.5，并不会输出&quot;middle&quot;</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result: &quot;</span>, result)&#125;).then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;middle&quot;</span>)&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err&quot;</span>, err)&#125;)</code></pre><p>另外，Promise 内部的错误不会影响到 Promise 外部的代码。通俗的说法就是“Promise 会吃掉错误”。</p><h2 id="8-5-回调函数"><a href="#8-5-回调函数" class="headerlink" title="8.5 回调函数"></a>8.5 回调函数</h2><p>一直以来都有一个误解，以为只有js有回调函数。。。后来才发现不是这样的，很多编程语言对“回调函数”（callback，或者说“call after”）都有相应的实现方式。 编程语言以不同的方式支持回调，通常使用子例程，lambda表达式，block或函数指针。</p><p>wiki上回调函数的解释：<code>a callback is a reference to executable code, or a piece of executable code, that is passed as an argument to other code.</code> ( 回调是对可执行代码或一段可执行代码的引用，该引用作为参数传递给其他代码 )</p><p>wiki上C语言和js实现回调的例子如下：</p><pre><code class="hljs c"><span class="hljs-comment">/* C */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/* The calling function takes a single callback as a parameter. */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTwoNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*numberSource)(<span class="hljs-keyword">void</span>))</span> </span>&#123;    <span class="hljs-keyword">int</span> val1 = numberSource();    <span class="hljs-keyword">int</span> val2 = numberSource();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d and %d\n&quot;</span>, val1, val2);&#125;<span class="hljs-comment">/* A possible callback */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">overNineThousand</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> (rand()%<span class="hljs-number">1000</span>) + <span class="hljs-number">9001</span>;&#125;<span class="hljs-comment">/* Another possible callback. */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">meaningOfLife</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<span class="hljs-comment">/* Here we call PrintTwoNumbers() with three different callbacks. */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">time_t</span> t;    srand((<span class="hljs-keyword">unsigned</span>)time(&amp;t)); <span class="hljs-comment">// Init seed for random function</span>    PrintTwoNumbers(&amp;rand);    PrintTwoNumbers(&amp;overNineThousand);    PrintTwoNumbers(&amp;meaningOfLife);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/* javascript */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">num1, num2, callbackFunction</span>) </span>&#123;    <span class="hljs-keyword">return</span> callbackFunction(num1, num2);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcProduct</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;    <span class="hljs-keyword">return</span> num1 * num2;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcSum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;    <span class="hljs-keyword">return</span> num1 + num2;&#125;<span class="hljs-comment">// alerts 75, the product of 5 and 15</span>alert(calculate(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, calcProduct));<span class="hljs-comment">// alerts 20, the sum of 5 and 15</span>alert(calculate(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, calcSum));</code></pre><p>C传递的是指针，js中传递的是引用。二者还是很相似的，所以C语言那个例子用js来写也是可以的。不过引用和指针二者的区别对我来说就有点复杂了，暂时还理不清楚。</p><h2 id="8-7-let-和-var"><a href="#8-7-let-和-var" class="headerlink" title="8.7 let 和 var"></a>8.7 <a href="https://www.cnblogs.com/songzxblog/p/11137117.html">let 和 var</a></h2><ul><li><p>块级作用域（一对花括号{}即是一个块级作用域）。</p><p>在let出现前，js没有函数没有块级作用域，只有<a href="#domain">函数作用域</a></p><pre><code class="hljs javascript">&#123;    <span class="hljs-keyword">var</span> i = <span class="hljs-number">9</span>&#125;<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 9</span>&#123;    <span class="hljs-keyword">let</span> j = <span class="hljs-number">9</span>&#125;<span class="hljs-built_in">console</span>.log(j) <span class="hljs-comment">// ReferenceError: j is not defined</span></code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++</span>)</span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">// 先执行循环，i自增到10，之后再依次执行setTimeout</span>        <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">// 10 10 10 10 10 10 10 10 10 10</span>    &#125;, <span class="hljs-number">0</span>)&#125;<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++</span>)</span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">// 每一个块作用域里的i值都不会受到外界影响，i值为对应的0~9</span>        <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9</span>    &#125;, <span class="hljs-number">0</span>)&#125;</code></pre></li></ul><h2 id="8-8-和"><a href="#8-8-和" class="headerlink" title="8.8 == 和 ==="></a>8.8 == 和 ===</h2><p>===是严格运算符,  ==是相等运算符</p><ul><li><p>===的比较规则</p><ul><li>不同类型值: false</li><li>同一类的<strong>原始类型</strong>值: 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。</li><li>同一类的<strong>复合类型</strong>值: 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。</li></ul></li><li><p>==的比较规则</p><ul><li>相同类型: 与===完全一样。</li><li>不同类型值: 先将数据进行类型转换，然后再用===进行比较。</li></ul></li></ul><h2 id="8-16-对象"><a href="#8-16-对象" class="headerlink" title="8.16 对象"></a>8.16 对象</h2><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;</code></pre><pre><code class="hljs dart"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()</code></pre><p>上述两种方法创建结果基本是一样的，所创建的新对象都继承自Object.prototype</p><h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><ul><li><p>点号<code>.</code>如果属性名特殊的话可能无法以该方式访问</p></li><li><p>中括号<code>[]</code></p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-string">&#x27;123&#x27;</span>: <span class="hljs-string">&#x27;456&#x27;</span>&#125;<span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">&#x27;123&#x27;</span>])<span class="hljs-comment">// 456</span><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-number">123</span>])<span class="hljs-comment">// 456</span><span class="hljs-comment">// console.log(obj.&#x27;123&#x27;) SyntaxError: Unexpected string</span><span class="hljs-comment">// console.log(obj.123)  SyntaxError</span></code></pre><h4 id="遍历and判断属性存在"><a href="#遍历and判断属性存在" class="headerlink" title="遍历and判断属性存在"></a>遍历and判断属性存在</h4><ul><li><p>**遍历: ** for <code>变量名</code> in <code>对象</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;obj.name = <span class="hljs-string">&quot;鲲鲲&quot;</span>obj.sing = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sing&quot;</span>) &#125;obj.jump = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;jump&quot;</span>) &#125;obj.rap = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rap&quot;</span>) &#125;<span class="hljs-comment">/* 遍历 */</span><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">// 属性名</span>    <span class="hljs-built_in">console</span>.log(obj[i])<span class="hljs-comment">// 变量值(属性的值)</span>&#125;<span class="hljs-comment">// name  鲲鲲</span><span class="hljs-comment">// sing  () =&gt; &#123; console.log(&quot;sing&quot;) &#125;</span><span class="hljs-comment">// jump  () =&gt; &#123; console.log(&quot;jump&quot;) &#125;</span><span class="hljs-comment">// rap   () =&gt; &#123; console.log(&quot;rap&quot;) &#125;</span></code></pre></li><li><p>**判断: ** 判断对象是否存在某个属性可以使用 <code>&#39;属性&#39;</code>  in <code>对象</code>，注意要给属性名加上引号，否则属性会被当做变量处理</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> obj)  <span class="hljs-comment">// true </span><span class="hljs-built_in">console</span>.log(name <span class="hljs-keyword">in</span> obj)<span class="hljs-comment">// ReferenceError: name is not defined</span></code></pre></li></ul><h2 id="8-18-数据类型"><a href="#8-18-数据类型" class="headerlink" title="8.18 数据类型"></a>8.18 数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p>共5种：Number, String, Boolean, Null, Undefined</p></li><li><p>存放：栈空间</p></li><li><p>比较：直接对值进行比较</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>对象</li><li>存放：堆空间</li><li>比较：比较引用的地址</li></ul><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-keyword">var</span> b = a;a++;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a=&quot;</span>, a);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b=&quot;</span>, b);<span class="hljs-keyword">var</span> obj1 = &#123;&#125;obj1.name = <span class="hljs-string">&#x27;鲲鲲&#x27;</span>;<span class="hljs-keyword">var</span> obj2 = obj1;obj1.name = <span class="hljs-string">&#x27;碧萝&#x27;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;obj1: &quot;</span>, obj1)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;obj2: &quot;</span>, obj2)</code></pre><p>示意图：</p><img src="https://cdn.jsdelivr.net/gh/LitStronger/pic@master/post/jsNotes/pro_pic.png" /><p>Actually, 基本/引用数据类型在进行比较时都是对栈空间的值进行比较</p><pre><code class="hljs pgsql">var obj1 = &#123;&#125;obj1.name = <span class="hljs-string">&#x27;鲲鲲&#x27;</span>;var obj2 = &#123;&#125;obj2.name = <span class="hljs-string">&#x27;鲲鲲&#x27;</span>;console.log(obj1 == obj2)      // <span class="hljs-keyword">false</span> 比较地址console.log(obj1.name == obj2.name)// <span class="hljs-keyword">true</span>  属性<span class="hljs-type">name</span>是基本数据类型，直接比较两者的值</code></pre><h2 id="8-19-函数"><a href="#8-19-函数" class="headerlink" title="8.19 函数"></a>8.19 函数</h2><h3 id="1-函数参数"><a href="#1-函数参数" class="headerlink" title="1.函数参数"></a>1.函数参数</h3><ul><li>一一对应，多余的参数会被忽略</li></ul><h3 id="2-函数也是对象"><a href="#2-函数也是对象" class="headerlink" title="2.函数也是对象"></a>2.函数也是对象</h3><ul><li><p>**函数具有对象的一切特点 **</p></li><li><p><strong>函数是功能更强大的对象</strong>，可以封装代码</p></li><li><p><strong>创建函数的方式</strong></p><ul><li><p>函数声明的方式</p><p>拥有默认属性<code>name</code> ，其值对应函数名，无法直接修改（除非修改函数名）</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;It is function&quot;</span>)&#125;fun.name = <span class="hljs-string">&#x27;鲲鲲&#x27;</span>fun.name1 = <span class="hljs-string">&#x27;碧萝&#x27;</span>fun.age = <span class="hljs-number">18</span><span class="hljs-built_in">console</span>.log(fun.name)  <span class="hljs-comment">// fun  属性name无法修改</span><span class="hljs-built_in">console</span>.log(fun.name1) <span class="hljs-comment">// 碧萝</span><span class="hljs-built_in">console</span>.log(fun.age)   <span class="hljs-comment">// 18</span><span class="hljs-built_in">console</span>.log(fun)    <span class="hljs-comment">// 函数体</span>   <span class="hljs-comment">// ƒ fun()&#123;</span>       <span class="hljs-comment">//     console.log(&quot;It is function&quot;)</span>   <span class="hljs-comment">// &#125;</span></code></pre></li><li><p>创建对象的方式(少用)</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&quot;console.log(&#x27;It is Function!&#x27;)&quot;</span>)fun()<span class="hljs-comment">// It is Function!</span></code></pre></li><li><p>赋值表达式的方式 </p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;It is Function!&#x27;</span>)&#125;;fun()<span class="hljs-comment">// It is Function!</span><span class="hljs-built_in">console</span>.log(fun.name)<span class="hljs-comment">// fun</span></code></pre></li></ul></li></ul><h2 id="8-21-作用域"><a href="#8-21-作用域" class="headerlink" title="8.21 作用域"></a>8.21 作用域</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1.全局作用域"></a>1.全局作用域</h3><p><strong>1.1 以var声明:</strong></p><ul><li><p>只要不是函数内声明的变量，都是全局变量</p></li><li><p>浏览器环境下，全局变量(方法)都是window对象的属性(方法)</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 全局  script中会预解析</span></span><span class="javascript">    b = <span class="hljs-number">11</span>;         <span class="hljs-comment">// 全局  未声明就赋值，默认为全局变量归全局window所有，不会报错</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> c = <span class="hljs-number">12</span>;<span class="hljs-comment">// 局部</span></span><span class="javascript">        d = <span class="hljs-number">13</span>;<span class="hljs-comment">// 全局</span></span><span class="javascript">        <span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 12</span></span><span class="javascript">    <span class="hljs-built_in">console</span>.log(d); <span class="hljs-comment">// 13</span></span>    &#125;<span class="javascript"><span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">// ReferenceError: c is not defined</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 10</span></span><span class="javascript">    <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 11</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p>生命周期：跟window一样(浏览器页面打开时创建–页面关闭时销毁)</p></li></ul><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2.局部作用域"></a>2.局部作用域</h3><p>**<span id="funDomain">2.1 函数作用域:</span>  **</p><ul><li><p>作用范围：函数内部</p><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-comment">// 局部</span>    b = <span class="hljs-number">11</span>;<span class="hljs-comment">// 全局</span>&#125;fun()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b=&quot;</span>, b) <span class="hljs-comment">// b= 11</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a=&quot;</span>, a) <span class="hljs-comment">// ReferenceError: a is not defined</span>&lt;/script&gt;</code></pre></li><li><p>生命周期：使用函数时创建，使用完后销毁（注意，声明函数时，变量并不会被创建）</p></li></ul><p><strong>2.2块级作用域</strong></p><ul><li><p>作用范围：一对花括号<code>&#123;&#125;</code>内(通常一对<code>&#123;&#125;</code>就是一个块)</p><pre><code class="hljs javascript">&#123;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 1</span>&#125;<span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// ReferenceError: c is not defined</span></code></pre><p>注意，var在函数中声明的变量是局部变量，但在非函数的<code>&#123;&#125;</code>中，则是全局的</p><pre><code class="hljs javascript">&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 全局</span>&#125;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 局部</span>&#125;<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// ReferenceError: b is not defined</span></code></pre></li></ul><h2 id="8-24-构造函数"><a href="#8-24-构造函数" class="headerlink" title="8.24 构造函数"></a>8.24 构造函数</h2><ul><li><p><strong>函数名首字母大写 。</strong>不大写也不会报错，但这是约定熟成的规范吧。其他人看到大写字母能直接意识到这是个构造函数，方便理解</p></li><li><p><strong>使用new关键字创建实例。</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello everybody! My name is &quot;</span> + <span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;, I am &quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot; years old! &quot;</span>)    &#125;&#125;<span class="hljs-keyword">var</span> kunKun = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&#x27;鲲鲲&#x27;</span>,<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(kunKun) <span class="hljs-comment">// People &#123; name: &#x27;鲲鲲&#x27;, age: 3, say: [Function] &#125;</span>kunKun.say()<span class="hljs-comment">// Hello everybody! My name is 鲲鲲, I like playing basketball</span></code></pre></li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN</a></p><p><img src="https://img-blog.csdnimg.cn/20201203214905426.png" alt="在这里插入图片描述"></p><p>**hasOwnProperty()**可用于检测一个属性是存在于实例中(返回<code>true</code>)，还是存在于原型中(返回<code>false</code>)</p><p><strong>in</strong>则与上述不同，只要能通过该对象访问到给定属性时返回<code>true</code>，无论是在原型中还是实例中</p><p><strong>for-in</strong>返回原型中和实例中所有可通过对象访问、可枚举的属性。注意，原来不可枚举的，如<code>toString()</code>，如果被重写了、并且没把[[Enumerable]]设置为false，也会在<code>for-in</code>循环中返回</p><h2 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h2><ul><li><p>undefined派生自null，因此在经过操作数转换后二者判定为相等，相等性测试如下</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>==<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>===<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span></code></pre></li><li><p>变量在声明后会默认得到一个undefined值，因此代码中给变量初始化一个undefined值并没有意义。而null则不同，如果变量准备用于存放对象，那么你可以给它赋值为null，可以体现null作为对象空指针的惯例（c语言中对指针也是这么做的）</p></li></ul><h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2 !=0.3"></a>0.1+0.2 !=0.3</h2><pre><code class="hljs js"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> = <span class="hljs-number">0.30000000000000004</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>) <span class="hljs-comment">//false</span></code></pre><ul><li><p>基于ieee754数值浮点计算的通病，c语言也有这个问题。尽量不要直接拿浮点数来进行比较（浮点数本身可能就不精确）</p></li><li><p>解决： 可以加个容差，比如 |0.1+0.2-0.3| &lt;= 0.00001(允许的误差值，根据需求情况自己限定)</p></li></ul><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>json：javascript object notation(符号)，通常用于前后端通信。其他类型的语言也有使用json，如java，php等</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-cli添加组件</title>
    <link href="/2020/04/14/vue-cli%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/04/14/vue-cli%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、流程结构"><a href="#一、流程结构" class="headerlink" title="一、流程结构"></a>一、流程结构</h3><p>在添加组件前呢，先了解一下vue项目的运行流程。</p><ul><li>整个项目的入口是main.js，在开头就引入了vue源码和主页面App.vue。</li><li>之后是生成一个Vue实例，把App.vue的内容渲染到浏览器上<br><img src="https://img-blog.csdnimg.cn/20200414202705396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200414203303903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="二、新建组件"><a href="#二、新建组件" class="headerlink" title="二、新建组件"></a>二、新建组件</h3>为新建的vue项目添加组件，一般是放在文件夹components下，然后在App.vue（或者其他你想引入组件的地方）导入组件</li></ul><h4 id="160-160-160-160-（1）新建组件list"><a href="#160-160-160-160-（1）新建组件list" class="headerlink" title="&#160; &#160; &#160; &#160;（1）新建组件list"></a>&#160; &#160; &#160; &#160;（1）新建组件list</h4><p><img src="https://img-blog.csdnimg.cn/20200414204020916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.msg&quot;</span>&gt;</span></span><span class="xml">            </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.msg</span>&#125;&#125;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">export default &#123;</span><span class="xml">    data () &#123;</span><span class="xml">        return &#123;</span><span class="xml">            items: [</span><span class="xml">                &#123;msg: &#x27;liao&#x27;&#125;,</span><span class="xml">                &#123;msg: &#x27;yue&#x27;&#125;,</span><span class="xml">                &#123;msg: &#x27;qiang&#x27;&#125;</span><span class="xml">            ]</span><span class="xml">        &#125;</span><span class="xml">    &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h4 id="160-160-160-160-（2）引入App-vue并使用组件"><a href="#160-160-160-160-（2）引入App-vue并使用组件" class="headerlink" title="&#160; &#160; &#160; &#160;（2）引入App.vue并使用组件"></a>&#160; &#160; &#160; &#160;（2）引入App.vue并使用组件</h4><p><img src="https://img-blog.csdnimg.cn/20200414221631190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>事实上，新建的项目里已经有一个组件了，就是components下的HelloWorld.vue。</p><p><img src="https://img-blog.csdnimg.cn/20200414202400512.png" alt="在这里插入图片描述"></p><h4 id="160-（3）之后在浏览器就可以看到自己的list组件的效果了"><a href="#160-（3）之后在浏览器就可以看到自己的list组件的效果了" class="headerlink" title="&#160;（3）之后在浏览器就可以看到自己的list组件的效果了"></a>&#160;（3）之后在浏览器就可以看到自己的list组件的效果了</h4><p><img src="https://img-blog.csdnimg.cn/20200414204254630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单、双、三列布局</title>
    <link href="/2020/04/07/%E5%8D%95%E3%80%81%E5%8F%8C%E3%80%81%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/"/>
    <url>/2020/04/07/%E5%8D%95%E3%80%81%E5%8F%8C%E3%80%81%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="一、单列水平居中布局"><a href="#一、单列水平居中布局" class="headerlink" title="一、单列水平居中布局"></a>一、单列水平居中布局</h4><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">height</span>:  <span class="hljs-number">300px</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#66ccff</span>;&#125;</code></pre><h4 id="二、双列布局"><a href="#二、双列布局" class="headerlink" title="二、双列布局"></a>二、双列布局</h4><p>(1)自适应(比较少用), 把宽度改成实际的像素值即可固定宽度。</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<span class="hljs-comment">/*清除默认样式*/</span>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.wrapper</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>; <span class="hljs-comment">/*要固定宽度的话，可以采用具体的像素值，如200px*/</span>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#66ccff</span>;&#125;<span class="hljs-selector-class">.right</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">float</span>: right;    <span class="hljs-attribute">background-color</span>: gray;&#125;</code></pre><h4 id="三、三列布局"><a href="#三、三列布局" class="headerlink" title="三、三列布局"></a>三、三列布局</h4><pre><code class="hljs css"><span class="hljs-selector-class">.body</span>&#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;     <span class="hljs-comment">/*清除浏览器默认样式*/</span>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.left</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">background-color</span>: red;        <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.middle</span>&#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">background-color</span>: lightblue;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">310px</span> <span class="hljs-number">0</span> <span class="hljs-number">210px</span>;&#125;<span class="hljs-selector-class">.right</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;    <span class="hljs-attribute">background-color</span>: gray;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;&#125;</code></pre><p>更多<a href="https://litstronger.github.io/2020/04/02/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E6%B5%AE%E5%8A%A8-vs-inline-block%EF%BC%89/">三列布局</a></p><p>而利用前面的单列，双列和三列布局，我们可以搭配出混合布局，如在单列布局的div中，再放入单列布局的div和三列布局div。(这就是套娃吧)</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-fluid添加utterances评论功能</title>
    <link href="/2020/04/03/hexo-fluid%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/04/03/hexo-fluid%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p><strong>8.21 更新:</strong> </p><ul><li><p>请使用最最新版fluid(目前是1.83)</p></li><li><p>请使用最最新版fluid(目前是1.83)</p></li><li><p>请使用最最新版fluid(目前是1.83)</p></li></ul><p>虽然时小白一枚，但觉得给博客添加个评论区应该还是挺简单的，但没想到竟因为英语太菜踩了一下午雷(黑脸)，网上也暂时搜不到针对Hexo-Fluid添加评论的教程，于是忽草草地做了个记录避免再次踩坑。</p><h4 id="一、新建一个github仓库"><a href="#一、新建一个github仓库" class="headerlink" title="一、新建一个github仓库"></a>一、新建一个github仓库</h4><p>首先创建一个公开的<a href="https://github.com/">github</a>仓库，按下图填完信息后Create repository创建<br><img src="https://img-blog.csdnimg.cn/20200403090041977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="新建github仓库"></p><h4 id="二、安装utterances"><a href="#二、安装utterances" class="headerlink" title="二、安装utterances"></a>二、安装utterances</h4><p>安装<a href="https://github.com/apps/utterances">utterances app</a>(点击前往安装)，install(安装)按钮未登陆github时不会显示，已安装则显示的是configure。(为了演示笔者还特地卸载重装了一遍)</p><p><img src="https://img-blog.csdnimg.cn/20200403091025505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择刚刚建好的github仓库，然后点击安装<br><img src="https://img-blog.csdnimg.cn/20200403091339639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h4><p><a href="https://utteranc.es/">前往配置</a></p><p><img src="https://img-blog.csdnimg.cn/20200403091754763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>建议选择第三个<br><img src="https://img-blog.csdnimg.cn/20200403092149860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>【可选项】根据个人需求选择是否为issue打上标签(label)。作为小白的我就暂时不设置了(留空)<br><img src="https://img-blog.csdnimg.cn/20200403092734150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>然后是主题，根据个人喜好选择吧<br><img src="https://img-blog.csdnimg.cn/20200403092756479.png" alt="在这里插入图片描述"></p></li><li><p>上述步骤填写完成后，最后一栏会根据你前面的操作自动生成配置信息(后面会用到)<br><img src="https://img-blog.csdnimg.cn/20200403092916235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>到此，对utterances的配置就完成了，接下来把它应用到我们的Hexo-Fluid</p></li></ul><h4 id="四、添加到Hexo-Fluid"><a href="#四、添加到Hexo-Fluid" class="headerlink" title="四、添加到Hexo-Fluid"></a>四、添加到Hexo-Fluid</h4><p> 打开配置文件(hexo/themes/fluid/_config.yml)，将enable设置为true以开启评论<br><img src="https://img-blog.csdnimg.cn/20200403093446392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在后面找到comments的具体配置<br><img src="https://img-blog.csdnimg.cn/20200403093654915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改后保存文件，重启hexo， 就可以看到文章下多了评论区啦！<br><img src="https://img-blog.csdnimg.cn/20200403093850559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果发现有评论区但无法评论，可能是没有授权github(右下角有提示授权的地方)。如果还是没有评论区的话，可以打开浏览器控制台看看错误提示。也欢迎在评论区提出你的问题！</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三栏布局（float/inline-block/flex）</title>
    <link href="/2020/04/02/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E6%B5%AE%E5%8A%A8-vs-inline-block%EF%BC%89/"/>
    <url>/2020/04/02/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E6%B5%AE%E5%8A%A8-vs-inline-block%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="三栏浮动布局"><a href="#三栏浮动布局" class="headerlink" title="三栏浮动布局"></a>三栏浮动布局</h4><p>浮动的方式有很多种，比如像下面这个例子，是把左右两个板块固定大小和位置，中间自适应。<br>先看效果</p><h6 id="窗口最大化"><a href="#窗口最大化" class="headerlink" title="窗口最大化"></a>窗口最大化</h6><p><img src="https://img-blog.csdnimg.cn/20200405215117765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="缩小化"><a href="#缩小化" class="headerlink" title="缩小化"></a>缩小化</h6><p><img src="https://img-blog.csdnimg.cn/20200405215243882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>三栏浮动布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.wrapper</span>&#123;</span>            width: 100%;            height: calc(100vh);            background-color: bisque;            box-sizing: border-box;        &#125;<span class="css">        <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.left</span> &#123;</span>            width: 200px;            height: 300px;<span class="css">            <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#faa</span>;</span>            float: left;        &#125;<span class="css">        <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.right</span> &#123;</span>            width: 200px;            height: 300px;<span class="css">            <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#afa</span>;</span>            float: right;        &#125;<span class="css">        <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.content</span> &#123;</span>            height: 300px;<span class="css">            <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#aaf</span>;</span><span class="css">            <span class="hljs-selector-tag">margin</span><span class="hljs-selector-pseudo">:0</span> 200<span class="hljs-selector-tag">px</span>;</span>        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 三栏浮动布局 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>在缩小窗口后，左边和右边的板块就会把中间的板块挤掉，或者覆盖重叠<br>（窗口缩小后就只能看到左右栏，这感觉就很像某些网页侧边广告，不信你试试）。<br><img src="https://img-blog.csdnimg.cn/20200402090239909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>缩小后<br><img src="https://img-blog.csdnimg.cn/20200402090258364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="inline-block方式"><a href="#inline-block方式" class="headerlink" title="inline-block方式"></a>inline-block方式</h4><p>使用外部div添加align-center属性，内部三个板块添加inline-block属性来实现<br>先看效果吧</p><h6 id="窗口最大化-1"><a href="#窗口最大化-1" class="headerlink" title="窗口最大化"></a>窗口最大化</h6><p><img src="https://img-blog.csdnimg.cn/20200402091801337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="缩小后"><a href="#缩小后" class="headerlink" title="缩小后"></a>缩小后</h6><p><img src="https://img-blog.csdnimg.cn/20200402091851190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>三栏inline-block布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"><span class="hljs-selector-class">.main-container</span>&#123;</span>  position: absolute;  background-color: darkgrey;  text-align: center;  margin-left: 0;  margin-right: 0;  left: 0;  right: 0;&#125;<span class="css"><span class="hljs-selector-class">.part-left</span>&#123;</span><span class="css">  <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#0ac276</span>;</span>  display: inline-block;&#125;<span class="css"><span class="hljs-selector-class">.part-right</span>&#123;</span>  background-color: aqua;      display: inline-block;&#125;<span class="css"><span class="hljs-selector-class">.part-center</span>&#123;</span>  background-color: coral;      display: inline-block;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-container&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-left&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background-color: blue;&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-right&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background-color: brown;&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-center&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background-color: rgb(51, 30, 30);&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>当然如果你想让这几个板块之间保持间距，可以为目标div添加上margin属性，比如margin-left或者margin-right这样。浮动和非浮动这两种方法各有特点（也许可以做到一样的效果呢，可能是我太菜了没想到而已）</p><h4 id="使用Flex实现"><a href="#使用Flex实现" class="headerlink" title="使用Flex实现"></a>使用Flex实现</h4><p>关于Flex介绍可以看看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮老师的blog</a><br>先看效果</p><h6 id="窗口最大化-2"><a href="#窗口最大化-2" class="headerlink" title="窗口最大化"></a>窗口最大化</h6><p><img src="https://img-blog.csdnimg.cn/2020040520121733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="缩小化-1"><a href="#缩小化-1" class="headerlink" title="缩小化"></a>缩小化</h6><p><img src="https://img-blog.csdnimg.cn/2020040520133954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.wrapper</span>&#123;</span>      background-color: bisque;      width: 100%;<span class="css">      <span class="hljs-selector-tag">height</span>: <span class="hljs-selector-tag">calc</span>(100<span class="hljs-selector-tag">vh</span>);  <span class="hljs-comment">/*设置div的高度height为calc(100vh)即可,100vh = 视窗高度的100%*/</span></span><span class="css">      <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">flex</span>;           <span class="hljs-comment">/*弹性布局*/</span></span><span class="css">      <span class="hljs-selector-tag">justify-content</span>: <span class="hljs-selector-tag">center</span>; <span class="hljs-comment">/*水平居中*/</span></span><span class="css">      <span class="hljs-selector-tag">align-items</span>: <span class="hljs-selector-tag">center</span>;     <span class="hljs-comment">/*垂直居中*/</span></span>    &#125;<span class="css">    <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.part-left</span>&#123;</span>      background-color: rgb(161, 59, 59);      width: 200px;      height: 200px;    &#125;<span class="css">    <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.part-center</span>&#123;</span>      background-color: rgb(58, 156, 58);      width: 200px;      height: 200px;    &#125;<span class="css">    <span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-class">.part-right</span>&#123;</span>      background-color: darkturquoise;      width: 200px;      height: 200px;    &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;part-right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>目前个人比较喜欢用inline-block和flex方法吧。float其实也行，不过的话要注意清除浮动，否则会出现意料之外的情况.</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie &amp;&amp; session (nodejs下)</title>
    <link href="/2020/03/31/cookie-session-nodejs%E4%B8%8B/"/>
    <url>/2020/03/31/cookie-session-nodejs%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>最近用nodejs写一个资讯的后台用到了cookie和session，这里做下总结吧。</p><h4 id="一、常见流程"><a href="#一、常见流程" class="headerlink" title="一、常见流程"></a>一、常见流程</h4><ul><li>客户端访问服务器，服务端响应时附带上cookie</li><li>浏览器将cookie保存到本地</li><li>之后访问服务器，浏览器会将cookie发送到服务器端（可以设置是否发送，详见path属性）</li></ul><h4 id="二、参数选项"><a href="#二、参数选项" class="headerlink" title="二、参数选项"></a>二、参数选项</h4><ul><li><strong>Path</strong>: cookie影响的路径，默认为’/‘(即访问所有路径都会发送cookie)。自定义设置后，访问路径不匹配时则不会发送这个cookie</li><li><strong>Expires</strong>：cookie的过期时间。未设置时，则cookie会在关闭浏览器时丢失。</li><li><strong>maxAge</strong>    ：cookie的有效时长(以毫秒为单位)。</li><li><strong>HttpOnly</strong>：设置后，cookie值在document.cookie将不可见，浏览器端将无法通过脚本document.cookie去更改cookie。</li><li><strong>Domain</strong>：设置cookie的作用域</li><li><strong>Secure</strong>：设为true时，cookie将只在https连接中传递，无法在在http中传递。</li></ul><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>模块用的是express-session<br><a href="https://www.npmjs.com/package/express-session#cookiesamesite">https://www.npmjs.com/package/express-session#cookiesamesite</a></p><h4 id="一、简单流程："><a href="#一、简单流程：" class="headerlink" title="一、简单流程："></a>一、简单流程：</h4><ul><li>客户端首次访问某网站</li><li>服务器生成cookie并初始化session，将session ID保存到cookie中，</li><li>响应时把包含sessionID的cookie发送给客户端，客户端保存cookie到本地</li><li>客户端再次访问时则会发送包含sessionID的cookie，服务器端就可以根据cookie里的sessionID来做相应的操作了（这取决于项目本身）</li></ul><h4 id="二、参数选项："><a href="#二、参数选项：" class="headerlink" title="二、参数选项："></a>二、参数选项：</h4><ul><li><strong>cookie</strong>：详见上文</li><li><strong>secret</strong>：用来注册session ID到cookie中，相当于一个密钥</li><li><strong>genid</strong>：设置创建session ID的自定义函数(默认使用”uid-safe”的库生成id)<br>如<pre><code class="hljs actionscript">genid: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> genuuid()<span class="hljs-comment">// 生成uuid作为session id</span>&#125;genid: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;genid_test&#x27;</span> <span class="hljs-comment">// 注意返回的id最好是不重复的，我这里只是随便返回一个值做测试</span>&#125;</code></pre><img src="https://img-blog.csdnimg.cn/20200331141102778.png" alt="1,2为genuuid()生成，3则为我自己的测试"></li></ul><ul><li><p><strong>name</strong>:  可以理解为sessionID保存在cookie中的键值的名称，该值在响应时设置, 之后可以在浏览器发送请求时在requset中读取。默认值为’connect.sid’<br>如设置</p><p><code>name=&#39;session-id&#39;</code></p><p><code>genid=&#39;genid_test&#39;</code>  </p><p>那么客户端的cookie中将会有</p><p><code>session-id：包含sessionID的字符串</code></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200331155521309.png" alt="在这里插入图片描述"></p><ul><li><strong>resave</strong>：强制session保存到session store，即便没有发生变化。通常来说，建议设置为false(<a href="https://www.npmjs.com/package/express-session#cookiesamesite">详见</a>)。</li><li><strong>rolling</strong>：每次请求时强制设置cookie，这将重置cookie的过期时间(maxAge)。（ps:设置为true，而saveUninitialized设置为false时，那么未初始化的session中的cookie请求时将不会刷新重置时间。）</li><li><strong>saveUninitialized</strong>：强制保存未初始化的session。默认为true。(ps：如果把这个值设置为true但是saveUnitialized设置为false,那么cookie不会被包含在响应中(没有初始化的session))</li><li><strong>store</strong>： session存储的实例子，一般可以用redis和mongodb来实现</li></ul><p>session初始化：当用户第一次访问网站的时候，由于Cookies中没有这个合法的SessionID存在，所以服务器会初始化用户的会话，随机分配一个SessionID给他，并写入到用户的Cookies里面。这个SessionID关联的Session就代表了用户的会话信息，这个过程就是初始化会话。</p><h4 id="三、登陆验证的配置"><a href="#三、登陆验证的配置" class="headerlink" title="三、登陆验证的配置"></a>三、登陆验证的配置</h4><p>对于一个网站，如果要求必须登陆才能访问的话，可以考虑对session使用如下配置</p><pre><code class="hljs yaml"><span class="hljs-string">session(&#123;</span><span class="hljs-attr">cookie:</span> &#123; <span class="hljs-string">//</span> <span class="hljs-string">根据项目需求配置吧</span>        &#125;<span class="hljs-string">,</span> <span class="hljs-attr">resave:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">rolling:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-string">每次访问都刷新cookie</span><span class="hljs-attr">saveUninitialized:</span> <span class="hljs-literal">false</span><span class="hljs-string">//</span> <span class="hljs-string">不保存未初始化的session</span><span class="hljs-string">store:new</span> <span class="hljs-string">sessionStore(&#123;</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">config.db.url</span>   <span class="hljs-string">//</span> <span class="hljs-string">把session存放在数据库，这里用了connect-mongo模块</span> <span class="hljs-string">&#125;)</span><span class="hljs-string">&#125;)</span></code></pre><p>resave通常情况下设置false就行了(避免浏览器多个请求同时发送时发生竞争)。一般来说，对于已经登陆的用户，我们会对其session添加一些属性来表示用户处于登陆状态，比如登陆成功时设置<code>req.session.user=&#39;login&#39;</code>。而rolling和saveUninitialized分别为true和false的搭配，可以做到</p><ul><li>未登录用户的session不会保存到数据库(未对session进行操作，没有初始化)；访问登陆界面时服务器也不会发送cookie给客户端。</li><li>已登陆用户的session添加登陆状态(初始化)后，将保存在数据库中，并且发送一个携带sessionID的cookie给客户端。</li></ul>]]></content>
    
    
    <categories>
      
      <category>session</category>
      
    </categories>
    
    
    <tags>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git归档</title>
    <link href="/2020/03/19/Git%E5%BD%92%E6%A1%A3/"/>
    <url>/2020/03/19/Git%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>为什么置顶? 当然是因为我也经常忘记一些 git 命令啦！方便查阅</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200319073359889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY0MTg1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Workspace: 工作区<br>Index/Stage: 暂存区<br>Repository: 仓库区（或者说 ‘本地仓库’ ）<br>Remote: 远程仓库</p><h2 id="一、最简单提交总流程"><a href="#一、最简单提交总流程" class="headerlink" title="一、最简单提交总流程"></a>一、最简单提交总流程</h2><p>把本地代码上传到远程仓库，最简单的流程是</p><pre><code class="hljs shell">(一)在项目根目录下初始化一个本地仓库<span class="hljs-meta">$</span><span class="bash"> git init </span><span class="hljs-meta">#</span><span class="bash"> 显示当前的Git配置(按q退出查看)</span><span class="hljs-meta">$</span><span class="bash"> git config --list</span><span class="hljs-meta">#</span><span class="bash"> 编辑Git配置文件，设置提交代码时的用户信息</span><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;[name]&quot;</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global user.email <span class="hljs-string">&quot;[email address]&quot;</span></span>(二)把全部代码提交到暂存区<span class="hljs-meta">$</span><span class="bash"> git add .  注意add和.之间有个空格 </span><span class="hljs-meta">$</span><span class="bash"> git status   查看状态</span>(三)把暂存区的代码提交到本地仓库<span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;&quot;</span>引号内填入本次修改的简述，例如初始化可填<span class="hljs-string">&quot;init&quot;</span>  </span>(四)添加远程仓库<span class="hljs-meta">$</span><span class="bash"> git remote add &lt;reomote-name&gt; &lt;url&gt;  名字自取，不需要跟远程仓库一模一样。</span><span class="hljs-meta">#</span><span class="bash"> 默认的主分支是master</span><span class="hljs-meta">$</span><span class="bash"> git push -u &lt;remote-name&gt;  master</span></code></pre><p><strong>示例：</strong></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;github账户名&quot;</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global user.email <span class="hljs-string">&quot;github邮箱&quot;</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global user.password <span class="hljs-string">&quot;github密码&quot;</span></span>注: 上面的三个信息仅在首次使用需要配置，以后就不需要了<span class="hljs-meta">$</span><span class="bash"> git add .</span><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;init&quot;</span></span><span class="hljs-meta">$</span><span class="bash"> git push -u origin master </span></code></pre><p>注: 参数-u设置–set-upstream，记住本次push时的参数，以后可直接git push</p><blockquote><p>The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do.</p></blockquote><p>至此就已经把代码提交到仓库上啦！<br>下面是我整理的一些常用的命令</p><h2 id="二、增加-删除文件"><a href="#二、增加-删除文件" class="headerlink" title="二、增加/删除文件"></a>二、增加/删除文件</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt;  添加文件到暂存区,多个文件用空格隔开</span><span class="hljs-meta">$</span><span class="bash"> git add &lt;dir&gt;   提交指定目录到暂存区，包括子目录</span><span class="hljs-meta">$</span><span class="bash"> git add .  添加所有文件到暂存区</span><span class="hljs-meta">#</span><span class="bash"> 如果你只想把某个文件保存在工作区使用，而不想将其添加到暂存区时</span><span class="hljs-meta">#</span><span class="bash">（通常情况是你不想把这个文件提交到远程仓库才需要这么做）</span><span class="hljs-meta">$</span><span class="bash"> git rm --cached &lt;file&gt;  停止追踪该文件</span><span class="hljs-meta">$</span><span class="bash"> git rm -r --cached &lt;dir&gt;   停止追踪该文件夹，-r是递归处理</span><span class="hljs-meta">#</span><span class="bash"> 还有一个常用的方法是创建.gitignore文件，关于.gitignore请自行网上查阅</span></code></pre><h2 id="三、代码提交："><a href="#三、代码提交：" class="headerlink" title="三、代码提交："></a>三、代码提交：</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m  <span class="hljs-string">&quot;[message]&quot;</span>  提交暂存区的文件到仓库区 </span></code></pre><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来</p><h2 id="四、分支相关："><a href="#四、分支相关：" class="headerlink" title="四、分支相关："></a>四、分支相关：</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch  查看分支</span><span class="hljs-meta">$</span><span class="bash"> git branch &lt;name&gt;  创建分支</span><span class="hljs-meta">$</span><span class="bash"> git checkout &lt;name&gt;  切换分支</span><span class="hljs-meta">$</span><span class="bash"> git merge &lt;name&gt;  合并某分支到当前分支</span><span class="hljs-meta">$</span><span class="bash"> git branch -d &lt;name&gt;  或者  $ git branch --delete &lt;name&gt; </span></code></pre><h2 id="五、远程同步"><a href="#五、远程同步" class="headerlink" title="五、远程同步"></a>五、远程同步</h2><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote 查看远程库简略信息</span><span class="hljs-meta">$</span><span class="bash"> git remote -v 查看远程库详细信息</span><span class="hljs-meta">#</span><span class="bash"> 添加新的远程仓库,名字可以自由定义,不需要跟远程仓库保持一致</span><span class="hljs-meta">$</span><span class="bash"> git remote add &lt;remote-name&gt; &lt;url&gt;  </span></code></pre><h3 id="1-本地仓库-gt-远程仓库"><a href="#1-本地仓库-gt-远程仓库" class="headerlink" title="1. 本地仓库=&gt;远程仓库"></a>1. 本地仓库=&gt;远程仓库</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;把分支推上远程仓库</span><span class="hljs-meta">#</span><span class="bash"> 如果想要一次推向多个仓库，可以用一个关联多个仓库,格式如下</span><span class="hljs-meta">$</span><span class="bash"> git remote set-url --add &lt;remote-name&gt; &lt;branch-name&gt;</span><span class="hljs-meta">#</span><span class="bash"> 例(remote-name用origin，branch-name用master):</span><span class="hljs-meta">$</span><span class="bash"> git remote set-url --add origin &lt;url-1&gt;  关联url-1 </span><span class="hljs-meta">$</span><span class="bash"> git remote set-url --add origin &lt;url-2&gt;  关联url-2</span><span class="hljs-meta">$</span><span class="bash"> git remote set-url --add origin &lt;url-3&gt;  关联url-3</span><span class="hljs-meta">$</span><span class="bash"> git remote origin master推送分支master到origin关联的三个仓库</span><span class="hljs-meta">#</span><span class="bash"> 如果push一直报错，提示你应该先把远程的最新版本拉取下来，</span><span class="hljs-meta">#</span><span class="bash"> 然而你觉得远程库的代码已经是废品没必要拉去下来时，可以</span><span class="hljs-meta">#</span><span class="bash"> 把本地代码强制push到远程仓库（注意，会直接覆盖原有的文件）</span><span class="hljs-meta">$</span><span class="bash"> git push -f &lt;remote-name&gt; &lt;branch-name&gt;  -f 强制，force</span></code></pre><h3 id="2-远程仓库-gt-本地仓库"><a href="#2-远程仓库-gt-本地仓库" class="headerlink" title="2. 远程仓库 =&gt; 本地仓库"></a>2. 远程仓库 =&gt; 本地仓库</h3><p><strong>方式一：git fetch + git merge(推荐)</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载远程仓库的分支暂存在本地仓库分支，不会覆盖工作区</span><span class="hljs-meta">$</span><span class="bash"> git fetch &lt;remote-name&gt; &lt;branch&gt;:&lt;temp-branch&gt; </span><span class="hljs-meta">#</span><span class="bash"> 把远程仓库的分支合并到当前本地的分支，注意第二个参数是远程仓库的分支名</span><span class="hljs-meta">$</span><span class="bash"> git merge &lt;temp-branch&gt; </span></code></pre><p>通常用法：</p><pre><code class="hljs pgsql"># 把远程仓库origin的master分支暂存到<span class="hljs-keyword">temp</span>分支(若不存在则会自动创建)$ git <span class="hljs-keyword">fetch</span> origin master:<span class="hljs-keyword">temp</span>$ git diff <span class="hljs-keyword">temp</span> 查看当前分支与<span class="hljs-keyword">temp</span>分支的不同处$ git merge <span class="hljs-keyword">temp</span> 合并<span class="hljs-keyword">temp</span>分支到当前分支$ git branch -d <span class="hljs-keyword">temp</span> 删除<span class="hljs-keyword">temp</span>分支</code></pre><p><strong>方式二：git pull</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载远程仓库到工作区</span><span class="hljs-meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;branch-name&gt;      </span></code></pre><p><code>git pull</code>相当于是使用固定参数地从远程<code>fetch</code>最新版本并<code>merge</code>(合并)到本地，这样有一个缺点，少了<code>git diff</code>查看远程分支与本地的差异的过程，如果有冲突的话它也会直接merge，虽然之后依旧可以手动修改冲突部分(<a href="https://blog.csdn.net/yangchunshang/article/details/80281699">详见</a>)，但有可能导致严重的后果。</p><p><code>git pull</code> ≈ <code>git fetch</code> + <code>git merge</code>，通常<code>git fetch</code>更安全一些, git pull慎用</p><p>更多资料：</p><ul><li><p>不懂教到懂系列、保姆式教程：<a href="https://www.imooc.com/article/20411">https://www.imooc.com/article/20411</a></p></li><li><p>更多实用命令参见阮老师的文章：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p></li></ul><p>一整个星期下来，看了两三个牛人的技术生涯，忽然就觉得自己的格局还是那么的小。<br>这是个13岁编程，60岁总结自己的一生，并不是觉得他有多么的厉害，而是这份总结写的实在是非常贴切真实。<br><a href="https://hackernoon.com/what-happened-to-software-development-j92032w9#subscribe-embed">https://hackernoon.com/what-happened-to-software-development-j92032w9#subscribe-embed</a></p><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/">https://www.cnblogs.com/ECJTUACM-873284962/</a></p><p>这个世界真的很大，有很多有趣的思想，独特的人格。诸多类型的信仰，总有一种适合自己的。开阔视野慢慢寻找，好好生活吧！</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治法求第K大元素</title>
    <link href="/2020/03/17/%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2020/03/17/%E5%88%86%E6%B2%BB%E6%B3%95%E6%B1%82%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>注：本文不对快速排序作任何解释，建议在对快速排序有一定了解后再阅览</p><h3 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h3><p>最简单的做法应该是直接选择先将集合排序（比如快速排序），然后直接以k为下标从有序集合中获取。但是这样做时间复杂度其实是比较大的。如果要想要提升一下效率，可以考虑在快速排序的原理下稍微做点修改。</p><h3 id="二、修改快排"><a href="#二、修改快排" class="headerlink" title="二、修改快排"></a><strong>二、修改快排</strong></h3><p><strong>1、主元素的位置特殊性</strong></p><p>在快速排序中，第一步是选取主元素（这里记为x），然后将小于主元素x的数放在x左边，剩下的所有大于x的数放在x右边。记x的下标为x_index，这里不难发现，此时x正是集合中第x_index（如果下标从0开始算，则是x_index+1）大的元素。</p><p><strong>2、题目情景特殊性—-只求一个数</strong><br>​<br>按照快速排序的步骤，接下来是将左、右两个子集合分别重复上述的“选取主元素，其余元素按照大小放主元素左右两边”的操作，但事实题目只是要求找到一个第k大的元素。那么，左右两个子集是不是可以考虑舍去一个？（类似于二分法，只取一半）显然可以！我们可以将k与x_index进行比较，分三种情况，当</p><p>k = x_index 时，说明已经找到了</p><p>k &lt; x_index 时，说明第k大元素在x左边的子集里，可以舍去右边部分</p><p>k &gt; x_index 时，说明第k大元素在x右边的子集里，可以舍去左边部分</p><p><strong>3、C代码实现：</strong></p><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<span class="hljs-built_in">int</span> exchange(<span class="hljs-built_in">int</span> *a, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j)&#123;<span class="hljs-built_in">int</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = temp;&#125;<span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span> *a, <span class="hljs-built_in">int</span> p, <span class="hljs-built_in">int</span> r)&#123;<span class="hljs-built_in">int</span> x = a<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>;<span class="hljs-built_in">int</span> i = p-<span class="hljs-number">1</span>, j;<span class="hljs-keyword">for</span>(j = p; j &lt; r; j++)&#123;<span class="hljs-keyword">if</span>(a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &lt; x)&#123;i++;exchange(a, i, j);<span class="hljs-comment">//交换下标为 i和 j 两个数的位置  </span>&#125;&#125;exchange(a, i+<span class="hljs-number">1</span>, r); return i+<span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">int</span> quick<span class="hljs-constructor">_sort(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">p</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">find</span>)</span>&#123;<span class="hljs-keyword">if</span>(p &lt; r)&#123;<span class="hljs-built_in">int</span> x_index = partition(a, p, r); <span class="hljs-comment">//获取主元素下标</span>printf(<span class="hljs-string">&quot;主元素下标x_index=%d\n&quot;</span>, x_index);<span class="hljs-keyword">if</span>(k<span class="hljs-operator"> == </span>x_index)&#123;*find = <span class="hljs-number">1</span>;printf(<span class="hljs-string">&quot;find number k = %d\n&quot;</span>, a<span class="hljs-literal">[<span class="hljs-identifier">x_index</span>]</span>);return <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &lt; x_index)&#123;quick<span class="hljs-constructor">_sort(<span class="hljs-params">a</span>, <span class="hljs-params">p</span>, <span class="hljs-params">x_index</span>-1, <span class="hljs-params">k</span>, <span class="hljs-params">find</span>)</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &gt; x_index)&#123;quick<span class="hljs-constructor">_sort(<span class="hljs-params">a</span>, <span class="hljs-params">x_index</span>+1, <span class="hljs-params">r</span>, <span class="hljs-params">k</span>, <span class="hljs-params">find</span>)</span>;&#125;&#125; &#125; <span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123; <span class="hljs-built_in">int</span> find = -<span class="hljs-number">1</span>, k;     printf(<span class="hljs-string">&quot;请输入k值&quot;</span>); scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k); k = k -<span class="hljs-number">1</span>;  <span class="hljs-comment">//因为数组下标是从0开始算的，这里需要对应地做点调整</span> <span class="hljs-built_in">int</span> a<span class="hljs-literal">[]</span> = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;;  <span class="hljs-comment">//试验数组 </span>  quick<span class="hljs-constructor">_sort(<span class="hljs-params">a</span>, 0, 6, <span class="hljs-params">k</span>, &amp;<span class="hljs-params">find</span>)</span>; <span class="hljs-comment">//因为在整个递归过程中，存在x_index与k一直不相等的情况（实际上就是递归到底时，</span> <span class="hljs-comment">//x恰好就是是k的相邻元素）。这里用find来标记是否相等。 不过无妨，到了最后，即</span> <span class="hljs-comment">//便整个数组可能不是有序的，但是下标x_index和k所对应的数，已经恰好是第</span> <span class="hljs-comment">//x_index大和第k大的数了，目的已经达成 ，将对应下标k的元素输出即可 </span> <span class="hljs-keyword">if</span>(find<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//find为-1说明没有在quick_sort没有找到 k 元素</span> printf(<span class="hljs-string">&quot;find number k = %d\n&quot;</span>, a<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>); &#125;  <span class="hljs-comment">/*这里打印当前数组元素的顺序，与题目无关，仅仅是想看看数组最后的顺序 */</span>  <span class="hljs-built_in">int</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123;printf(<span class="hljs-string">&quot;%d &quot;</span>, a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);&#125; &#125;</code></pre><h3 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h3><p><strong>采用主定理分析复杂度：</strong></p><p>每次都考虑一个子问题，a=1，</p><ul><li>best-case(每次主元素都取到中间值)  b=2</li></ul><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)+Θ(<span class="hljs-built_in">n</span>）     =&gt;Θ(lgn)</code></pre><ul><li>worse-case(每次主元素都取到最大或者最小值）</li></ul><pre><code class="hljs excel"><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">T</span>(<span class="hljs-number">0</span>) + <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + Θ(<span class="hljs-built_in">n</span>）     = <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + Θ(<span class="hljs-built_in">n</span>)     =&gt;Θ(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)</code></pre><p>事实上主元素采用random方式选取会使这个算法更加稳定。但是我看了下，它的时间复杂度好难算（我不会），所以不了不了，简单点好0_0</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用初识</title>
    <link href="/2020/03/16/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E8%AF%86/"/>
    <url>/2020/03/16/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核编译及添加系统调用"><a href="#linux内核编译及添加系统调用" class="headerlink" title="linux内核编译及添加系统调用"></a>linux内核编译及添加系统调用</h1><p><strong>本文图片已经失效，同步更新到CSDN的文章仍是完整的，<a href="https://blog.csdn.net/weixin_43641850/article/details/104906726">点击前往</a></strong></p><p>注：文章共四部分，分别是</p><p>1、编译更换内核</p><p>2、添加一个简单系统系统调用</p><p>3、添加读取/修改nice值的系统调用</p><p>4、自己设计简单（真的简单）系统调用</p><p>四个部分结构相似，请根据自身需求自行选择观看。</p><blockquote><p>Tip: 预安装的内核尽量选择与原系统内核版本相近的内核，可选择版本稍微高些的。内核版本差异过大将会出现很多意料之外的错误。如本实验环境中linux1604内核为4.12版本，可考虑使用4.16作为预安装版本</p></blockquote><p><strong>相关实验资源：</strong><br>1、kernel内核源码文档<br><a href="https://elixir.bootlin.com/linux/latest/source/include">https://elixir.bootlin.com/linux/latest/source/include</a></p><p>2、Linux系统版本：Ubuntu16.04<br><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/16.04/">ubuntu1604 清华源镜像</a></p><p>3、预安装内核linux-4.16.1<br><a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/">linux-4.16内核清华源镜像</a></p><hr><h2 id="一-、下载新内核并编译、更换："><a href="#一-、下载新内核并编译、更换：" class="headerlink" title="(一)、下载新内核并编译、更换："></a>(一)、下载新内核并编译、更换：</h2><h3 id="第一步：下载解压-进入文件夹"><a href="#第一步：下载解压-进入文件夹" class="headerlink" title="第一步：下载解压,进入文件夹"></a>第一步：下载解压,进入文件夹</h3><pre><code class="hljs vala"><span class="hljs-meta"># wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.16.1.tar.xz (或者手动下载压缩包解压) </span><span class="hljs-meta"># xz –d linux-4.16.1.tar.xz</span><span class="hljs-meta"># tar –xvf linux-4.16.1.tar </span><span class="hljs-meta"># cd linux-4.16.1</span></code></pre><h3 id="第二步-：清楚残留的-config和-o文件"><a href="#第二步-：清楚残留的-config和-o文件" class="headerlink" title="第二步 ：清楚残留的 .config和 .o文件"></a>第二步 ：清楚残留的 .config和 .o文件</h3><p>每次编译出错或者重新编译最好都清理，不清理很占空间，会出现虚拟机存储空间不够的情况</p><pre><code class="hljs vala"><span class="hljs-meta"># make mrproper</span></code></pre><p> 报错提醒安装ncurses，重新执行make mrproper</p><pre><code class="hljs q"># apt-<span class="hljs-built_in">get</span> install libncurses5-<span class="hljs-built_in">dev</span></code></pre><h3 id="第三步：配置内核"><a href="#第三步：配置内核" class="headerlink" title="第三步：配置内核"></a>第三步：配置内核</h3><pre><code class="hljs vala"><span class="hljs-meta"># make menuconfig </span></code></pre><p>根据报错提示安装组件，缺啥装啥</p><pre><code class="hljs 1c"><span class="hljs-meta"># sudo apt install build-essential <span class="hljs-comment">//安装make和gcc等</span></span><span class="hljs-meta"># apt-get install libncurses5-dev <span class="hljs-comment">//安装ncurses-devel</span></span><span class="hljs-meta"># sudo apt-get install flex <span class="hljs-comment">//安装flex</span></span><span class="hljs-meta"># sudo apt-get install bison  <span class="hljs-comment">//安装bison</span></span></code></pre><p>没有报错后再执行</p><pre><code class="hljs vala"><span class="hljs-meta"># make menuconfig </span></code></pre><p>出现配置的对话框，直接保存（save），文件名也默认.config, 退出。</p><h3 id="第四步：编译内核，生成启动映像文件"><a href="#第四步：编译内核，生成启动映像文件" class="headerlink" title="第四步：编译内核，生成启动映像文件"></a>第四步：编译内核，生成启动映像文件</h3><pre><code class="hljs she&#39;l"># make -j4 &#x2F;&#x2F;-j4是指四线程，用于加快编译速度。ps:嫌慢不如试试-j32，听说即便没有这么多线程也能正常运行的</code></pre><p>报错提示要openssl，安装完再次执行命令即可</p><pre><code class="hljs q"># apt-<span class="hljs-built_in">get</span> install libssl-<span class="hljs-built_in">dev</span></code></pre><h3 id="第五步：编译模块"><a href="#第五步：编译模块" class="headerlink" title="第五步：编译模块"></a>第五步：编译模块</h3><p>这一步要好久（2-3小时，可能虚拟机配置太低吧）。。。。睡一觉回来就好了</p><pre><code class="hljs vala"><span class="hljs-meta"># make modules</span></code></pre><h3 id="第六步：安装内核、模块"><a href="#第六步：安装内核、模块" class="headerlink" title="第六步：安装内核、模块"></a>第六步：安装内核、模块</h3><pre><code class="hljs 1c">安装模块：<span class="hljs-meta"># make modules_install </span>安装内核：<span class="hljs-meta"># make install</span></code></pre><h3 id="第七步：配置-grub-引导程序"><a href="#第七步：配置-grub-引导程序" class="headerlink" title="第七步：配置 grub 引导程序"></a>第七步：配置 grub 引导程序</h3><p>只需要执行如下命令：该命令会自动修改 grub</p><pre><code class="hljs vala"><span class="hljs-meta"># update-grub2</span></code></pre><h3 id="最后一步重启："><a href="#最后一步重启：" class="headerlink" title="最后一步重启："></a>最后一步重启：</h3><pre><code class="hljs vala"><span class="hljs-meta"># reboot -n</span></code></pre><p>查看内核版本</p><pre><code class="hljs apache"><span class="hljs-comment"># uname -a</span></code></pre><p><img src="1582793333263.png"></p><p>成功更换内核！</p><h2 id="二-、添加简单系统调用"><a href="#二-、添加简单系统调用" class="headerlink" title="(二)、添加简单系统调用"></a>(二)、添加简单系统调用</h2><h3 id="第一步：修改源程序"><a href="#第一步：修改源程序" class="headerlink" title="第一步：修改源程序"></a>第一步：修改源程序</h3><pre><code class="hljs gradle"># cd linux-<span class="hljs-number">4.16</span>.<span class="hljs-number">1</span> <span class="hljs-comment">//进入linux解压包（我下的版本是4.16.1）</span># vim arch<span class="hljs-regexp">/x86/</span>entry<span class="hljs-regexp">/syscalls/</span>syscall_64.tbl <span class="hljs-comment">//进入该文件分配系统调用号 （注意别写在最后面，x64部分约300多行，别写到后面x32那一块里面）</span></code></pre><p><img src="1582793550595.png"></p><pre><code class="hljs autoit"><span class="hljs-meta"># vim <span class="hljs-meta-keyword">include</span>/linux/syscalls.h 进入该文件，添加服务例程的原型声明（shift+g快速跳到最后一行）</span></code></pre><p><img src="1582793882548.png"></p><pre><code class="hljs vala"><span class="hljs-meta"># vim kernel/sys.c 实现系统调用服务例程</span></code></pre><p>SYSCALL_DEFINE后的数字代表参数个数，这里0个参数（void）</p><p><img src="1582793980496.png"></p><h3 id="第二步：编译安装内核"><a href="#第二步：编译安装内核" class="headerlink" title="第二步：编译安装内核"></a>第二步：编译安装内核</h3><pre><code class="hljs vala"><span class="hljs-meta"># make menuconfig 配置内核</span><span class="hljs-meta"># make –j2 编译内核</span><span class="hljs-meta"># make modules 编译模块</span><span class="hljs-meta"># make modules_install 和 make install 安装模块和安装内核</span><span class="hljs-meta"># update-grub2（好像虚拟机不需要这一步）</span><span class="hljs-meta"># reboot –n 立即重启</span></code></pre><h3 id="第三步：新系统调用测试"><a href="#第三步：新系统调用测试" class="headerlink" title="第三步：新系统调用测试"></a>第三步：新系统调用测试</h3><p>这里编写一个test.c文件来测试（文件存放位置可以任意）</p><pre><code class="hljs vala"><span class="hljs-meta"># vim test.c</span></code></pre><p><img src="1582794361481.png"></p><p>编译</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> gcc test.c -o <span class="hljs-built_in">test</span> //-o <span class="hljs-built_in">test</span>指定编译输出文件名为<span class="hljs-built_in">test</span></span></code></pre><p><img src="1582794469277.png"></p><p>执行文件</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ./<span class="hljs-built_in">test</span></span></code></pre><p>查看信息</p><pre><code class="hljs vala"><span class="hljs-meta"># dmesg</span></code></pre><p><img src="1582794530603.png"></p><p>可见系统调用成功执行</p><h2 id="三-、添加API对指定进程的-nice-值的读取功能"><a href="#三-、添加API对指定进程的-nice-值的读取功能" class="headerlink" title="(三)、添加API对指定进程的 nice 值的读取功能"></a>(三)、添加API对指定进程的 nice 值的读取功能</h2><pre><code class="hljs reasonml">注：nice值表示进程可被执行的优先级的修正数值,加入nice值后，将会使得PRI变为：<span class="hljs-constructor">PRI(<span class="hljs-params">new</span>)</span>=<span class="hljs-constructor">PRI(<span class="hljs-params">old</span>)</span>+nice。这样，当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。</code></pre><p><code>pid</code>：进程ID</p><p><code>flag</code>：等于1表示修改，等于0表示读取</p><p><code>nicevalue</code>：为指定进程设置新的nice值</p><p><code>prio</code>，<code>nice</code>：指向进程当前优先级prio及nice值</p><h3 id="1-修改源程序"><a href="#1-修改源程序" class="headerlink" title="1.修改源程序"></a>1.修改源程序</h3><p>添加系统调用号</p><p><img src="1582796191989.png"></p><p>添加声明</p><p><img src="1582796356918.png"></p><p>具体代码实现</p><p><img src="1582800035795.png"></p><p>copy_to_user函数则是从内核空间拷贝内容到用户空间，用户空间的进程无法直接访问内核空间的内容。这个函数做了数据合法判断。然后进行拷贝。</p><pre><code class="hljs reasonml">static inline <span class="hljs-built_in">int</span> task<span class="hljs-constructor">_nice(<span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">task_struct</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span></code></pre><p>用于获取当前task的nice值，并返回nice值，nice值的范围是[ -20 … 0 … 19 ]<br>其使用的例程如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_user_nice</span><span class="hljs-params">(struct task_struct *p, <span class="hljs-keyword">long</span> nice)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">bool</span> queued, running;<span class="hljs-keyword">int</span> old_prio, delta;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq_flags</span> <span class="hljs-title">rf</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>;</span><span class="hljs-keyword">if</span> (task_nice(p) == nice || nice &lt; MIN_NICE || nice &gt; MAX_NICE)<span class="hljs-keyword">return</span>;&#125;</code></pre><h3 id="2-编译安装内核"><a href="#2-编译安装内核" class="headerlink" title="2.编译安装内核"></a>2.编译安装内核</h3><p>编译安装</p><pre><code class="hljs bash"><span class="hljs-comment"># make mrproper</span><span class="hljs-comment"># make -j4</span><span class="hljs-comment"># make modules</span><span class="hljs-comment"># make modules_install</span><span class="hljs-comment"># make install</span><span class="hljs-comment"># reboot -n</span></code></pre><h3 id="3-编写测试程序"><a href="#3-编写测试程序" class="headerlink" title="3.编写测试程序"></a>3.编写测试程序</h3><pre><code class="hljs powershell"><span class="hljs-comment"># vim test-nice.c  //在哪创建没有特别要求</span></code></pre><p><img src="1582941471840.png"></p><pre><code class="hljs stata"># gcc nice-<span class="hljs-keyword">test</span>.c -o nice-<span class="hljs-keyword">test</span>   <span class="hljs-comment">//编译，格式gcc &lt;c代码文件&gt; -o &lt;输出文件的文件名&gt;</span># ./nice-<span class="hljs-keyword">test</span> <span class="hljs-comment">//执行所生成的文件</span></code></pre><p><img src="1582941337513.png"></p><pre><code class="hljs 1c"><span class="hljs-meta"># dmesg<span class="hljs-comment">//查看信息</span></span></code></pre><p><img src="1582941916641.png"></p><h2 id="四-、自己设计系统调用"><a href="#四-、自己设计系统调用" class="headerlink" title="(四)、自己设计系统调用"></a>(四)、自己设计系统调用</h2><p>CONFIG_NR_CPUS是内核被配置支持的CPU个数，而实际设备的CPU个数是在系统启动过程当中去动态监测的。也就是说你配置系统支持32个CPU那么CONFIG_NR_CPUS就等于32，而num_online_cpus()则是当前设备激活可调度的CPU个数。</p><p>利用内核函数：</p><p><img src="1583398735285.png"></p><p>由于大致流程与前面相似，这里便不再详述</p><p>分配系统调用号（335）</p><p><img src="1583399550731.png"></p><p>添加服务例程原型声明</p><p><img src="1583399672061.png"></p><p>实现系统调用服务例程</p><p><img src="1583400246725.png"></p><p>编译安装</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> make mrproper</span><span class="hljs-meta">#</span><span class="bash"> make -j4</span><span class="hljs-meta">#</span><span class="bash"> make modules</span><span class="hljs-meta">#</span><span class="bash"> make modules_install</span><span class="hljs-meta">#</span><span class="bash"> make install</span><span class="hljs-meta">#</span><span class="bash"> reboot -n</span></code></pre><p>编写测试程序</p><p><img src="1583417793639.png"></p><p>编译执行后, dmesg查看信息，如图</p><p><img src="1583417777075.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux操作系统</tag>
      
      <tag>Ubuntu16.04</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
